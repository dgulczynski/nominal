% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk oraz rodzaj (lic/inz/mgr) pracy.
\documentclass[english, mgr]{iithesis}

\usepackage[utf8]{inputenc}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\englishtitle   {Nominal logic \fmlinebreak for reasoning about terms \fmlinebreak with variable bindings}
\polishtitle    {Logika dziedzinowa do wnioskowania \fmlinebreak o termach z wiązaniem zmiennych}
\polishabstract {Przedstawiamy logikę dziedzinową do wnioskowania o termach z wiązaniem zmiennych. }
\englishabstract{We describe logic for reasoning about terms with variable bindings.}
\author         {Dominik Gulczyński}
\advisor        {dr Piotr Polesiuk}
\date           {\today}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
\transcriptnum  {299391}                     % Numer indeksu
\advisorgen     {dr. Piotra Polesiuka} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd} % For \llbracket
\usepackage{macros}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{semantic}

%%%%% WŁASNE DEFINICJE I POLECENIA
% \definecolor{codegreen}{rgb}{0,0.6,0}
% \definecolor{codegray}{rgb}{0.5,0.5,0.5}
% \definecolor{codepurple}{rgb}{0.58,0,0.82}
% \definecolor{backcolour}{rgb}{0.95,0.95,0.92}
% \lstdefinestyle{ocamlstyle}{
%     commentstyle=\color{codegreen},
%     keywordstyle=\color{magenta},
%     numberstyle=\tiny\color{codegray},
%     stringstyle=\color{codepurple},
%     basicstyle=\ttfamily\footnotesize,
%     breakatwhitespace=false,
%     breaklines=true,
%     captionpos=b,
%     keepspaces=true,
%     numbers=left,
%     numbersep=5pt,
%     showspaces=false,
%     showstringspaces=false,
%     showtabs=false,
%     tabsize=2
% }
% \lstset{style=ocamlstyle}
%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}

\section{Problem statement}
\dots

\section{Motivation}
% Przykłady machania rękoma nad wiązaniem zmiennych w innych tekstach jako motywacja do tej pracy
\dots

\section{Related work}
\subsection{Nominal logics \& permutations}

\section{Contributions}
\dots

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Terms and constraints}
% Okreli odbiorce i do niego pisa

In classical first-order logic, terms are built from variables and
applications of functional symbols to other terms.
In this work we expand terms with expressions closely resembling the syntax
of lambda calculus, aiming to provide a flexible framework for reasoning about
the lambda calculus and its derivations.

To this end we introduce an infinite set of \textit{atoms}
(denoted by lower-case letters), representing the bound variables in terms
--- i.e. the variables in the sense of lambda calculus.
That set is disjount with the set of variables commonly found in first-order logic,
which from now on we will call \textit{variables} (and denote by uppper-case letters)
as apposed to \textit{atoms}.

Terms are given by the following grammar: \\
\begin{tabular}{rclr}
    $\perm$    & $\deff$ & $\permid
                   \bnfor \permswap{\atomexp}{\atomexp}{\perm}$
        & (permutations) \\
    $\atomexp$ & $\deff$ & $\perm \apperm \atomv$
        & (atom expressions) \\
    $\term$    & $\deff$ & $\atomexp
                   \bnfor \perm \apperm \termv
                   \bnfor \tbind{\atomexp} \term
                   \bnfor \term \tapp \term
                   \bnfor \symb$
        & (terms)
\end{tabular}
% Termy są czysto sytnatkyczne, opisać ich znaczenie, a model w innym rozdziale

It is important to note that terms do not incorporate any inherent notions of
computation, reduction, or binding.
These expressions simply \textit{look} like the lambda calculus but they lack
the operational semantics of it.
However, the intuitions associated with such expressions are not unfounded.
We will observe their practical application in the sublogic of constraints
that we define on top of terms to reason about
notions of \textit{freshness}, \textit{variable binding} and \textit{structural}
order and its logical model.

Constraints are given by the following grammar:
\\
\begin{tabular}{rclr}
    $\constr$  & $\deff$ & $\atomexp \cfresh \term
                   \bnfor \term \ceq \term
                   \bnfor \term \csheq \term
                   \bnfor \term \cshlt \term$
        & (constraints)
\end{tabular}
\\
with following semantics:
\begin{eqnarray*}
  \atomexp \cfresh \term & \text{---} & \text{
    atom $\atomexp$ is {Fresh} in term $\term$, i.e. does not occur in $\term$
    as a free variable
  } \\
  \term_1 \ceq \term_2 & \text{---} &\text{
    terms $\term_1$ and $\term_2$ are alpha-equivalent
  } \\
  \term_1 \csheq \term_2 & \text{---} &\text{
    terms $\term_1$ and $\term_2$ possess an identical shape,
  } \\
  & & \text{
    i.e. after erasing all atoms, terms $\term_1$ and $\term_2$ would be equal
  } \\
  \term_1 \cshlt \term_2 & \text{---} &\text{
    shape of term $\term_1$ is structurally smaller than the shape of term
    $\term_2$,
  } \\
  & & \text{
    i.e. after erasing all atoms $\term_1$ would be equal to some
    subterm of $\term_2$
  } \\
\end{eqnarray*}

We use metavariable $\cEnv$ for finite sets of constraints.


\begin{tabular}{rclr}
$\semterm$ & $\deff$ & $\sematom
               \bnfor n
               \bnfor \stbind \semterm
               \bnfor \semterm \stapp \semterm
               \bnfor \symb$
    & (semantic terms) \\
$\shape$   & $\deff$ & $\shatom
               \bnfor \shbind \shape
               \bnfor \shape \shapp \shape
               \bnfor \symb$
    & (semantic shapes)
\end{tabular}

\begin{eqnarray*}
  \termMdl{\perm \apperm \atomv}{\tmEnv} & = &
    \permMdl{\perm}{\tmEnv}(\tmEnv(\atomv)) \\
  \termMdl{\perm \apperm \termv}{\tmEnv} & = &
    \permMdl{\perm}{\tmEnv}(\tmEnv(\termv)) \\
  \termMdl{\tbind{\atomexp} \term}{\tmEnv} & = &
    \stbind (\termMdl{\term}{\tmEnv} \shiftIdx)
      \subst{\termMdl{\atomexp}{\tmEnv}}{0} \\
  \termMdl{\term_1 \tapp \term_2}{\tmEnv} & = &
    \termMdl{\term_1}{\tmEnv} \stapp \termMdl{\term_2}{\tmEnv} \\
  \termMdl{\symb}{\tmEnv} & = & \symb
\end{eqnarray*}

\begin{eqnarray*}
  \shapeof{\sematom}                     & = & \shatom \\
  \shapeof{n}                            & = & \shatom \\
  \shapeof{\stbind \semterm}             & = & \shbind \shapeof{\semterm} \\1
  \shapeof{\semterm_1 \stapp \semterm_2} & = &
    \shapeof{\semterm_1} \shapp \shapeof{\semterm_2}
\end{eqnarray*}

\begin{eqnarray*}
  \tmEnv \vDash \term_1 \ceq \term_2 & \textrm{iff} &
    \termMdl{\term_1}{\tmEnv} = \termMdl{\term_2}{\tmEnv} \\
  \tmEnv \vDash \atomexp \cfresh \term & \textrm{iff} &
    \termMdl{\atomexp}{\tmEnv} \notin
      \mathsf{FreeAtoms}(\termMdl{\term}{\tmEnv}) \\
  \tmEnv \vDash \term_1 \csheq \term_2 & \textrm{iff} &
    \shapeof{\termMdl{\term_1}{\tmEnv}} = \shapeof{\termMdl{\term_2}{\tmEnv}} \\
  \tmEnv \vDash \term_1 \cshlt \term_2 & \textrm{iff} &
    \shapeof{\termMdl{\term_1}{\tmEnv}} \textrm{ is a strict subshape of }
      \shapeof{\termMdl{\term_2}{\tmEnv}}
\end{eqnarray*}

We write $\tmEnv \vDash \cEnv$ iff for all $\constr \in \cEnv$
we have $\tmEnv \vDash \constr$.
We write $\cEnv \vDash \constr$ iff
for every $\tmEnv$ such that $\tmEnv \vDash \cEnv$
we have $\tmEnv \vDash \constr$.


With this model in mind we will se that there exists a decidibile algorithm
for determining whether C1,...,Cn |= C0,
i.e. a deterministic way of checking if constraints c1, ..., cn imply c0.
We present such algorithm in the next chapter.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Constraint solver}
Bird's eye view: Solver breaks down constraints (on both sides of the turnstile)
to irreducible components that are solved easily.


At the core of our work lies the Solver
--- the algorithm of resolving the constraints.
Given a list of assumptions $\constr_1, \dots, \constr_n$ it checks whether
given goal $\constr_0$ holds.
In other words it is an algorithm that verifies whether,
for every possible substitution of closed terms (in terms of variables, not atoms)
for variables in $\constr_0, \constr_1, \dots, \constr_n$ such that the constraints
$\constr_1, \dots, \constr_n$ are satisfied, $\constr_0$ is also satisfied.

For convenience and effectiveness of implementation, the Solver works with
constraints a little different constraints (although not more expressive)
than those occuring in formulas and kinds,
main difference being use of \textit{shapes} instead of terms for shape constraints.
Solver contraints and shapes are given by the following grammar: \\
\begin{tabular}{rclr}
  $\sconstr$ & $\deff$ & $\atomexp \cfresh \term
  \bnfor \term \ceq \term
  \bnfor \shape \csheq \shape
  \bnfor \shape \cshlt \shape$
      & (solver constraints) \\
  $\shape$      & $\deff$ & $\shatom
                 \bnfor  \termv
                 \bnfor \shbind \shape
                 \bnfor \shape \tapp \shape
                 \bnfor \symb$
      & (shapes)
\end{tabular}\\
Solver erases atoms from terms in shape contstraints, effectively transforming
them from \textit{constraints} to \textit{solver constraints}.

We add another environment $\icEnv$ to distinguish between the
potentially-reducible assumptions in $\cEnv$.
For convenience we will write $\atomv \cneq \atomexp$ instead of $\atomv \cfresh \atomexp$ as it gives
good intuition of atom freshness implying inequality
and for $\atomexp = \pi \atomv$ we will write $\atomexp \cfresh \term$ meaning
$\atomv \cfresh \pi^{-1} \term$.
Irreducible constraints are:
\begin{eqnarray*}
  \atomv_1 \cneq \atomv_2 & \text{---} & \text{
    atoms $\atomv_1$ and $\atomv_2$ are different
  } \\
  \atomv   \cfresh \termv   & \text{---} & \text{
    atom $\atomv$ is {Fresh} in variable $\termv$
  } \\
  \termv_1 \csheq  \termv_2 & \text{---} & \text{
    variables $\termv_1$ and $\termv_2$ posses the same shape
  } \\
  \termv   \csheq  \term    & \text{---} & \text{
    variable $\termv$ has a shape of term $\term$
  } \\
  \term    \cshlt  \termv   & \text{---} & \text{
    term $\term$ strictly subshapes variable $\termv$
  } \\
\end{eqnarray*}

After all the constraints are reduced to such simple constraints
we reduce the goal-constraint and repeat the reduction procedure on
new assumptions and goal. We either arrive on a contradictory environment or
all the assumptions and goal itself are reduced to irreducible constraints which
is as simple as checking if the goal occurs on the left side of the turnstile.

$$
\inferrule{
  \sconstr \in \icEnv
}{
  \cEnv ; \icEnv \vDash \sconstr
}
$$
Decidability of atom equality plays an important role in the reduce
procedure:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% solver goal eq
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$$
\inferrule{
  \cEnv ; \icEnv \vDash \atomv = \perm^{-1} \atomexp
}{
  \cEnv ; \icEnv \vDash \perm \atomv = \atomexp
}
\qquad
\inferrule{
  \atomv \cneq \atomexp_1, \atomv \cneq \atomexp_2, \cEnv ; \icEnv \vDash \atomv     = \atomexp \\
  \atomv \ceq  \atomexp_1, \atomv \cneq \atomexp_2, \cEnv ; \icEnv \vDash \atomexp_2 = \atomexp \\
  \atomv \ceq  \atomexp_2, \cEnv ; \icEnv \vDash \atomexp_1 = \atomexp
}{
  \cEnv ; \icEnv \vDash \atomv = \permswap{\atomexp_1}{\atomexp_2}{}\atomexp
}
$$
$$
\inferrule{
  \cEnv ; \icEnv \vDash \pi \text{ idempotent on } \termv
}{
  \cEnv ; \icEnv \vDash \termv = \pi \termv
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \termv_1 = \pi_1^{-1} \pi_2 \termv_2
}{
  \cEnv ; \icEnv \vDash \pi_1 \termv_1 = \pi_2 \termv_2
}
$$
$$
\inferrule{
  \cEnv ; \icEnv \vDash \atomexp_1 \cfresh \term_2
  \\
  \cEnv ; \icEnv \vDash \term_1 = \permswap{\atomexp_1}{\atomexp_2} \term_2
}{
  \cEnv ; \icEnv \vDash \tbind{\atomexp_1} \term_1 = \tbind{\atomexp_2} \term_2
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \term_1 = \term_2
  \\
  \cEnv ; \icEnv \vDash \term_1' = \term_2'
}{
  \cEnv ; \icEnv \vDash \term_1 \term_1' = \term_2 \term_2'
}
$$
$$\inferrule{
}{
  \cEnv ; \icEnv \vDash \atomv = \atomv
}
\qquad
\inferrule{
}{
  \cEnv ; \icEnv \vDash \termv = \termv
}
\qquad
\inferrule{
}{
  \cEnv ; \icEnv \vDash \symb = \symb
}
$$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% solver permutation idempotent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$$
\inferrule{
  \forall \atomv \in \pi.\;
    \cEnv ; \icEnv \vDash \atomv = \pi \atomv \;\vee\;
    \cEnv ; \icEnv \vDash \atomv \cfresh \termv
  }{
  \cEnv ; \icEnv \vDash \pi \text{ idempotent on } \termv
}
$$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% solver goal {Fresh}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$$\inferrule{
  \atomv_1 \cneq \atomv_2 \in \icEnv
}{
  \cEnv ; \icEnv \vDash \atomv_1 \cfresh \atomv_2
}
\qquad
\inferrule{
  \atomv \cneq \atomexp_1, \atomv \cneq \atomexp_2, \cEnv ; \icEnv \vDash \atomv     \cfresh \atomexp \\
  \atomv \ceq  \atomexp_1, \atomv \cneq \atomexp_2, \cEnv ; \icEnv \vDash \atomexp_1 \cfresh \atomexp \\
                          \atomv \ceq  \atomexp_2 , \cEnv ; \icEnv \vDash \atomexp_2 \cfresh \atomexp
}{
  \cEnv ; \icEnv \vDash \atomv \cfresh \permswap{\atomexp_1}{\atomexp_2}{} \atomexp
}
$$
$$\inferrule{
  \atomv \cfresh \termv \in \icEnv
}{
  \cEnv ; \icEnv \vDash \atomv \cfresh \termv
}
\qquad
\inferrule{
  \atomv \cneq \atomexp_1, \atomv \cneq \atomexp_2, \cEnv ; \icEnv \vDash \atomv     \cfresh \pi \termv \\
  \atomv \ceq  \atomexp_1, \atomv \cneq \atomexp_2, \cEnv ; \icEnv \vDash \atomexp_1 \cfresh \pi \termv \\
                          \atomv \ceq  \atomexp_2 , \cEnv ; \icEnv \vDash \atomexp_2 \cfresh \pi \termv
}{
  \cEnv ; \icEnv \vDash \atomv \cfresh \permswap{\atomexp_1}{\atomexp_2}{\pi} \termv
}
$$
$$\inferrule{
  \atomv \cneq \atomexp, \cEnv ; \icEnv \vDash \atomv \cfresh \term
}{
  \cEnv ; \icEnv \vDash \atomv \cfresh \tbind{\atomexp}{\term}
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \atomv \cfresh \term_1 \\
  \cEnv ; \icEnv \vDash \atomv \cfresh \term_2
}{
  \cEnv ; \icEnv \vDash \atomv \cfresh \term_1 \term_2
}
\qquad
\inferrule{
}{
  \cEnv ; \icEnv \vDash \atomv \cfresh \symb
}
$$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% solver goal shape
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$$
\inferrule{
  \termv_1 \csheq \termv_2 \in \icEnv
}{
  \cEnv ; \icEnv \vDash \termv_1 \csheq \termv_2
}
\qquad
\inferrule{
  \termv  \csheq \shape' \in \icEnv \\
  \cEnv ; \icEnv \vDash \shape'  \csheq \shape
}{
  \cEnv ; \icEnv \vDash \termv  \csheq \shape
}
$$
$$\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \csheq \shape_2
}{
  \cEnv ; \icEnv \vDash \shbind \shape_1 \csheq \shbind \shape_2
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \csheq \shape_2 \\
  \cEnv ; \icEnv \vDash \shape_1' \csheq \shape_2'
}{
  \cEnv ; \icEnv \vDash \shape_1 \shape_1' \csheq \shape_2 \shape_2'
}
\qquad
\inferrule{
}{
  \cEnv ; \icEnv \vDash \symb \csheq \symb
}
$$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% solver goal subshape
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$$\inferrule{
  \shape_2 \cshlt \termv \in \icEnv \\
  \cEnv ; \icEnv \vDash \shape_2 \csheq \termv
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \termv
}
\qquad
\inferrule{
  \shape_2 \cshlt \termv \in \icEnv \\
  \cEnv ; \icEnv \vDash \shape_2 \cshlt \termv
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \termv
}
$$
$$\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \csheq \shape_2
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shbind \shape_2
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shbind \shape_2
}
$$
$$\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \csheq \shape_2
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2 \shape_2'
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \csheq \shape_2'
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2 \shape_2'
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2 \shape_2'
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2'
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2 \shape_2'
}
$$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% solver assm eq
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$$
\inferrule{
  \atomv_1 \cneq \atomv_2 \in \icEnv
}{
  \atomv_1 \ceq \atomv_2, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
   \cEnv \subst{\atomv_1}{\atomv_2}; \icEnv\subst{\atomv_1}{\atomv_2} \vDash \sconstr\subst{\atomv_1}{\atomv_2}
}{
  \atomv_1 \ceq \atomv_2, \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \atomv \cneq \atomexp_1, \atomv \cneq \atomexp_2, \atomv     \ceq \atomexp, \cEnv ; \icEnv \vDash \sconstr \\
  \atomv \ceq  \atomexp_1, \atomv \cneq \atomexp_2, \atomexp_2 \ceq \atomexp, \cEnv ; \icEnv \vDash \sconstr \\
                           \atomv \ceq  \atomexp_2, \atomexp_1 \ceq \atomexp, \cEnv ; \icEnv \vDash \sconstr
}{
  \atomv \ceq \permswap{\atomexp_1}{\atomexp_1} \atomexp, \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \atomv \ceq \pi^{-1} \atomexp, \cEnv ; \icEnv \vDash \sconstr
}{
  \pi \atomv \ceq \atomexp, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
}{
   \atomv \ceq \term_1 \term_2, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
}{
   \atomv \ceq \tbind{\atomexp} \term , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
}{
   \atomv \ceq \symb , \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \vDash \text{ idempotent on } \termv
}{
   \termv = \pi \termv, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
  \pi \text{ idempotent on } \termv, \cEnv ; \icEnv \vDash \sconstr
}{
   \termv = \pi \termv, \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
   \cEnv\subst{\termv}{\term} ; \icEnv\subst{\termv}{\term} \vDash \sconstr\subst{\termv}{\term}
}{
   \termv = \term, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
   \termv = \pi^{-1} \term, \cEnv ; \icEnv \vDash \sconstr
}{
   \pi \termv = \term, \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
   \atomexp_1 \cfresh \tbind{\atomexp_2} \term_2,\; \term_1 = \permswap{\atomexp_1}{\atomexp_2}\term_2 , \; \cEnv ; \icEnv \vDash \sconstr
}{
   \tbind{\atomexp_1} \term_1 \ceq \tbind{\atomexp_2} \term_2 , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
$$
\inferrule{
  \term_1 \ceq \term_2 , \; \term_1' \ceq \term_2', \;\cEnv ; \icEnv \vDash \sconstr
}{
   \term_1 \term_1' \ceq \term_2 \term_2' , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
$$
\inferrule{
  \symb_1 \neq \symb_2
}{
  \symb_1 \ceq \symb_2 , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
}{
  \symb\ceq \symb , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% solver permutation idempotent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$$
\inferrule{
  (\forall \atomv \in \pi.\;
    \cEnv ; \icEnv \vDash \atomv = \pi \atomv \;\vee\;
    \cEnv ; \icEnv \vDash \atomv \cfresh \termv), \cEnv ; \icEnv \vDash \sconstr
}{
\pi \text{ idempotent on } \termv, \cEnv ; \icEnv \vDash \sconstr
}
$$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% solver assm {Fresh}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$$
\inferrule{
}{
  \atomv \cneq \atomv, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
  \cEnv ; \{\atomv_1 \cneq \atomv_2\} \cup \icEnv \vDash \sconstr
}{
  \atomv_1 \cneq \atomv_2, \; \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
  \cEnv ; \{\atomv \cfresh \termv\} \cup \icEnv \vDash \sconstr
}{
  \atomv \cfresh \termv, \; \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \atomv \cneq \atomexp_1, \atomv \cneq \atomexp_2, \atomv     \cfresh \atomexp, \cEnv ; \icEnv \vDash \sconstr \\
  \atomv \ceq  \atomexp_1, \atomv \cneq \atomexp_2, \atomexp_2 \cfresh \atomexp, \cEnv ; \icEnv \vDash \sconstr \\
                           \atomv \ceq  \atomexp_2, \atomexp_1 \cfresh \atomexp, \cEnv ; \icEnv \vDash \sconstr
}{
  \atomv \cfresh \permswap{\atomexp_1}{\atomexp_1} \atomexp, \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \atomv \cneq \atomexp_1, \atomv \cneq \atomexp_2, \atomv     \cfresh \termv, \cEnv ; \icEnv \vDash \sconstr \\
  \atomv \ceq  \atomexp_1, \atomv \cneq \atomexp_2, \atomexp_2 \cfresh \termv, \cEnv ; \icEnv \vDash \sconstr \\
                           \atomv \ceq  \atomexp_2, \atomexp_1 \cfresh \termv, \cEnv ; \icEnv \vDash \sconstr
}{
  \atomv \cfresh \permswap{\atomexp_1}{\atomexp_1} \termv, \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \atomv \cfresh \atomexp, \; \cEnv ; \icEnv \vDash \sconstr \\
  \atomv \cfresh \atomexp, \; \atomv \cfresh \term,\;\cEnv ; \icEnv \vDash \sconstr
}{
  \atomv \cfresh \tbind{\atomexp} \term , \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \atomv \cfresh \term_1 , \cEnv ; \icEnv \vDash \sconstr \\
  \atomv \cfresh \term_2 , \cEnv ; \icEnv \vDash \sconstr
}{
  \atomv \cfresh \term_1 \term_2 , \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \cEnv ; \icEnv \vDash \sconstr
}{
  \atomv \cfresh \symb, \cEnv ; \icEnv \vDash \sconstr
}
$$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% solver assm shape eq
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$$
\inferrule{
  \cEnv ; \{\termv_1 \csheq \termv_2\} \cup \icEnv \vDash \sconstr
}{
  \termv_1 \csheq \termv_2, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
  \cEnv ; \{\termv \csheq \shape\} \cup \icEnv \vDash \sconstr
}{
  \termv \csheq \shape,\; \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \cEnv ; \icEnv \vDash \sconstr
}{
  \atomv_1 \csheq \atomv_2, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
$$
\inferrule{
  \term_1 \csheq \term_2, \cEnv ; \icEnv \vDash \sconstr
}{
  \shbind\term_1 \csheq \shbind\term_2, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
$$
\inferrule{
  \term_1  \csheq \term_2 , \cEnv ; \icEnv \vDash \sconstr \\
  \term_1' \csheq \term_2', \cEnv ; \icEnv \vDash \sconstr
}{
  \term_1 \term_1' \csheq \term_2\term_2', \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
$$
\inferrule{
  \symb_1 \neq \symb_2
}{
  \symb_1 \csheq \symb_2 , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
}{
  \symb \csheq \symb , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% solver assm shape eq
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$$
\inferrule{
  \cEnv ; \{\term \cshlt \termv\} \cup \icEnv \vDash \sconstr
}{
  \term \cshlt \termv, \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \term_1 \csheq \term_2, \cEnv ; \icEnv \vDash \sconstr \\
  \term_1 \cshlt \term_2, \cEnv ; \icEnv \vDash \sconstr
}{
  \term_1 \cshlt \shbind \term_2, \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \term_1 \csheq \term_2, \cEnv ; \icEnv \vDash \sconstr \\
  \term_1 \csheq \term_2', \cEnv ; \icEnv \vDash \sconstr \\
  \term_1 \cshlt \term_2, \cEnv ; \icEnv \vDash \sconstr \\
  \term_1 \cshlt \term_2', \cEnv ; \icEnv \vDash \sconstr
}{
  \term_1 \cshlt \term_2 \term_2', \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
}{
  \term \cshlt \atomexp, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
}{
  \term \cshlt \symb, \cEnv ; \icEnv \vDash \sconstr
}
$$

TODO: explain what is $\{\sconstr\} \cup \icEnv$
Additional rule for ariving in contradictory $\icEnv$:
$$
\inferrule{
}{
  \cEnv ; \lightning \vDash \sconstr
}
$$


Define state of the solver by triple $(\cEnv, \icEnv, \sconstr_0)$ and such
ordering of the states:
\begin{enumerate}
  \item Number of distinct variables in $\cEnv$, $\icEnv$,$ \sconstr_0$.
  \item Depth of $\sconstr_0$.
  \item Number of assumptions of given depth in $\cEnv$ and $\icEnv$.
  \item Number of assumptions of given depth in $\cEnv$.
\end{enumerate}

Then by analysing each rule we can see the reductions always arrive in a smaller
state.

\section{Implementation}
Environment $\icEnv$ is a quintuple
$({NeqAtoms}_{\icEnv}
, {Fresh}_{\icEnv}
, {VarShape}_{\icEnv}
, {Shape}_{\icEnv}
, {Subshape}_{\icEnv}
)$ where: \\
$NeqAtoms$ is a set of pairs of atoms that we know are different, \\
$Fresh$ is a mapping from atoms to variables that we know the atom is {Fresh} in,\\
$VarShape$ is a mapping from variables to shape-representative variables (i.e. all variables that are mapped in $VarShape$ to the same variable are of the same shape),\\
$Shape$ is a mapping from shape-representative variables to shape that we know this variable must have,\\
$SubShape$ is a mapping from shape-representative variables to sets of shapes that we know this variable must supershape.
\\
\\
\newcommand{\shrep}[2][\icEnv]{\ensuremath{ #2_{#1}}}
\newcommand{\shenv}[2][\icEnv]{\ensuremath{ |#2|_{#1}}}
We can now define a way to compute the shape-representative variable:
$$
\shrep{\termv} :=
     \begin{cases}
      \termv          &\text{if } {VarShape}_{\icEnv}(\termv) = \emptyset \\
       \shrep{\termv'} &\text{if } {VarShape}_{\icEnv}(\termv) = \termv'
     \end{cases}
$$
And shape-reconstruction:
\begin{eqnarray*}
  \shenv{\termv}                 &:=&
  \begin{cases}
    \shenv{\termv'} &\text{if } {VarShape}_{\icEnv}(\termv) = \termv' \\
    \shape          &\text{if } {Shape}_{\icEnv}(\termv) = \shape \\
    \termv          &\text{otherwise}
  \end{cases} \\
  \shenv{\shatom}           &:=& \shatom \\
  \shenv{\shbind \shape}    &:=& \shbind \shenv{\shape} \\
  \shenv{\shape_1 \shape_2} &:=& \shenv{\shape_1} \shenv{\shape_2}\\
  \shenv{\symb}             &:=& \symb \\
  \shenv{\term}             &:=& \shenv{|\term|}
\end{eqnarray*}
\newcommand{\occurs}[2]{\ensuremath{ {#1}\text{ occurs in }{#2}}}
\newcommand{\stxoccurs}[2]{\ensuremath{ {#1}\text{ occurs syntactically in }{#2}}}
\newcommand{\pluseq}{\mathrel{+}=}
\newcommand{\minuseq}{\mathrel{-}=}
Now we can easily check for irreducible constraints in $\icEnv$:

\begin{eqnarray*}
  (\atomv_1 \cneq \atomv_2) \in \icEnv &:=& (\atomv_1 \cneq \atomv_2) \in {NeqAtoms}_{\icEnv} \\
  (\atomv \cfresh \termv) \in \icEnv &:=& \termv \in {Fresh}_{\icEnv}(\atomv) \\
  (\termv_1 \csheq \termv_2) \in \icEnv &:=& \shenv{\termv_1} \ceq \shenv{\termv_2} \\
  (\termv \csheq \shape) \in \icEnv &:=& \shape = {Shape}_{\icEnv}(\shrep{\termv})\\
  (\shape \cshlt \termv) \in \icEnv &:=& \shape \in {SubShape}_{\icEnv}(\shrep{\termv})
\end{eqnarray*}

Now we can define rules for the special occurs check:
$$
\inferrule{
  \stxoccurs{\shrep{\termv}}{\shenv{\shape}}
}{
  \icEnv \vDash \occurs{\termv}{\shape}
}
$$
$$
\inferrule{
  \stxoccurs{\shrep{\termv'}}{\shenv{\shape}} \\
  (\shape' \cshlt \termv') \in \icEnv  \\
  \icEnv \vDash \occurs{\termv}{\shape'}
}{
  \icEnv \vDash \occurs{\termv}{\shape}
}
$$
And finally the rules for $\sconstr \cup \icEnv$.
Note that we are using meta-field of $Assumptions$ to indicate that some of the
assumptions in $\icEnv$ are no longer "simple" and escape from $\icEnv$ back to
$\cEnv$ to be broken up by the \textit{Solver}.

$$
 \{\atomv \cfresh \termv\} \cup \icEnv := \icEnv[{Fresh}(\atomv) \pluseq \termv]
$$
$$
\{\atomv \cneq \atomv'\} \cup \icEnv :=
  \begin{cases}
    \lightning &\text{if } \atomv \ceq \atomv'  \\
    \icEnv[{NeqAtoms} \pluseq (\atomv \cneq \atomv')] &\text{otherwise.}
  \end{cases}
$$

\begin{eqnarray*}
\{\termv \csheq \shape\} \cup \icEnv & := &
  \begin{cases}
    \lightning     &\text{if } \icEnv \vDash \occurs{\termv}{\shape} \\
    \icEnv' &\text{otherwise.}\\
  \end{cases} \\
  \text{where } \icEnv' & = & \icEnv .{Symbols} \{\shrep{\termv} \leadsto \shenv{\shape} \}\\
                        &   & \quad .{Subshapes}\{\shrep{\termv} \leadsto \shenv{\shape} \} \\
                        &   & \quad .{Shape}    \{\shrep{\termv} \leadsto \shenv{\shape} \}
\end{eqnarray*}

\begin{eqnarray*}
\{\termv \csheq \termv'\} \cup \icEnv & := &
  \begin{cases}
    \icEnv     &\text{if } \shrep{\termv} \ceq \shrep{\termv'} \\
    \icEnv &\text{if } \shenv{\termv} \ceq \shenv{\termv'} \\
    \lightning     &\text{if } \occurs{\shrep{\termv}}{\shenv{\termv'}} \\
    \lightning     &\text{if } \occurs{\shrep{\termv'}}{\shenv{\termv}} \\
    \icEnv' &\text{otherwise.}\\
  \end{cases} \\
  \text{where } \icEnv' & = & \icEnv .{Symbols}     \{\shrep{\termv} \leadsto \shrep{\termv'}\}\\
                        &   & \quad .{Subshapes}    \{\shrep{\termv} \leadsto \shrep{\termv'}\} \\
                        &   & \quad .{TransferShape}\{\shrep{\termv} \leadsto \shrep{\termv'}\} \\
                        &   & \quad [\: {Shape}    \minuseq (\shrep\termv) \\
                        &   & \quad ,   {SubShape} \minuseq (\shrep\termv) \\
                        &   & \quad ,   {VarShape} \pluseq  (\shrep\termv \mapsto \shrep\termv') \\
                        &   & \quad ]
\end{eqnarray*}
$$
\icEnv.{Symbols}\{\termv \leadsto \shape\} :=
  \begin{cases}
    \icEnv[{Symbols} \minuseq \termv, {Assumptions} \pluseq \text{symbol } \shape]    &\text{if } \shrep{\termv} \in \icEnv.{Symbols} \\
    \icEnv &\text{otherwise.}\\
  \end{cases} \\
$$
$$
\icEnv.{Shape}\{\termv \leadsto \shape\} :=
  \begin{cases}
    \icEnv[{Assumptions} \pluseq (\shape \csheq \shape')]    &\text{if } {Shape}_{\icEnv}(\shrep\termv) = \shape' \\
    \icEnv[{Shapes}      \pluseq (\termv \mapsto \shape)] &\text{otherwise.}\\
  \end{cases} \\
$$
$$
\icEnv.{SubShapes}\{\termv \leadsto \shape\} :=
  \icEnv[{Assumptions} \pluseq {Subshapes}_{\icEnv}(\termv) \cshlt \shape]
$$
$$
\icEnv.{TransferShape}\{\termv \leadsto \termv'\} :=
  \begin{cases}
    \icEnv.{Shape}\{termv' \leadsto  \shape'\}    &\text{if } {Shape}_{\icEnv}(\shrep\termv) = \shape \\
    \icEnv &\text{otherwise.}\\
  \end{cases} \\
$$
$$
\icEnv\{\termv \mapsto \term\} := \{\termv \csheq \shenv{\term} \} \cup \icEnv.{Fresh}\{\termv \mapsto \term\}
$$
$$
\icEnv.{Fresh}\{\termv \mapsto \term\} :=
 \icEnv[{Fresh}.map(\text{fun } (\atomv \cfresh \mathbb{\termv}) \mapsto \atomv \cfresh (\mathbb{\termv} \setminus \{ \termv\})] \;
 \cup \bigcup_{\substack{(\atomv \cfresh \mathbb{\termv}) \in {Fresh}_{\icEnv} \\ \termv \in \mathbb{\termv}}}
    \{ \atomv \cfresh \term \}
$$
$$
\icEnv\{\atomv \mapsto \atomv'\} := \icEnv.{Fresh}\{\atomv \mapsto \atomv'\}.{NeqAtoms}\{\atomv \mapsto \atomv'\}]
$$
$$
\icEnv.{Fresh}\{\atomv \mapsto \atomv'\} := \icEnv[{Fresh} \minuseq \atomv][{Fresh} \pluseq \{\atomv' \cfresh \icEnv.{Fresh}(\atomv)\}]
$$
$$
\icEnv.{NeqAtoms}\{\atomv \mapsto \atomv'\} :=
\icEnv[{NeqAtoms} = \emptyset] \;
 \cup \bigcup_{ (\atomv_1 \cneq \atomv_2) \in {NeqAtoms}_{\icEnv}  }
    \{ \atomv_1\{\atomv \mapsto \atomv'\} \cneq \atomv_2\{\atomv \mapsto \atomv'\}\}
$$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Higher Order Logic}

On top of sublogic of constraints we build an higher order logic.
Due to involvement of atoms, terms, binders and constraints,
we introduce kinds to make sure the formulas we deal with \textit{make sense}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Kinds}

\begin{tabular}{rclr}
$\kind$ & $::=$ & $\kProp
            \bnfor \kind \karrow \kind
            \bnfor \kForallAtom{\atomv} \kind
            \bnfor \kForallTerm{\termv} \kind
            \bnfor \kGuard{\constr} \kind$
    & (kinds)
\end{tabular}

\begin{tabular}{rclr}
$\formphi \ofkind$ & $\kProp$ & ---  $\formphi$ is a propositional formula. \\
$\formphi \ofkind$ & $\kind_1 \karrow \kind_2$ & ---  $\formphi$ is function that takes a formula of kind $\kind_1$, \\
  & &  and produces a formula of kind $\kind_2$. \\
$\formphi \ofkind$ & $\kForallAtom{\atomv} \kind$ & ---  $\formphi$ is function that takes an an atom expression, \\
  & &  binds it to $\atomv$ and produces a formula of kind $\kind$.\\
$\formphi \ofkind$ & $\kForallTerm{\termv} \kind$ & ---  $\formphi$ is function that takes a term, \\
  & &  binds it to $\termv$ and produces a formula of kind $\kind$.\\
$\formphi \ofkind$ & $\kGuard{\constr} \kind$ & ---  $\formphi$ is a formula of kind $\kind$ as long as $\constr$ is satisfied.
\end{tabular}
\\ \\
Notice that as constraints occur in kinds, we cannot simply give functions
from atoms some kind ${Atom}\karrow\kind$, but we must know \textit{which} atom
is bound there, to substitute for it in $\kind$ the same way we substitute
that atom for an atom expression in the function body when applying it to the formula.
The \textit{guarded kind} $\kGuard{\constr} \kind$ is used in kinding of the fixpoint formulas
we will explain in later sections.

\section{Subkinding}
Kinding relation is relaxed through the \textit{subkinding},
a relation that is naturally reflexive and transitive:
$$
\inference{
}{
  \cEnv \vdash \kind \subkind \kind
}
\qquad
\inference{
  \cEnv \vdash \kind_1 \subkind \kind_2 &
  \cEnv \vdash \kind_2 \subkind \kind_3
}{
  \cEnv \vdash \kind_1 \subkind \kind_3
}
$$
Universally quantified kinds only subkind if they are quantified over the same name:
$$
\inference{
  \cEnv \vdash \kind_1 \subkind \kind_2
}{
  \cEnv \vdash \kForallAtom{\atomv} \kind_1 \subkind \kForallAtom{\atomv} \kind_2
}
\qquad
\inference{
  \cEnv \vdash \kind_1 \subkind \kind_2
}{
  \cEnv \vdash \kForallTerm{\termv} \kind_1 \subkind \kForallTerm{\termv} \kind_2
}
$$
Function kind is contravariant to the subkinding relation:
$$
\inference{
  \cEnv \vdash \kind_1' \subkind \kind_1 &
  \cEnv \vdash \kind_2 \subkind \kind_2'
}{
  \cEnv \vdash \kind_1 \karrow \kind_2 \subkind \kind_1' \karrow \kind_2'
}
$$
Constraints that are solved through $\vDash$ relation can be dropped:
$$
\inference{
  \cEnv \vDash \constr
}{
  \cEnv \vdash \kGuard{\constr}\kind \subkind \kind
}
$$
And constraints can be moved from right-hand side to the enviroment:
$$
\inference{
  \cEnv, \constr \vdash \kind_1 \subkind \kind_2
}{
  \cEnv \vdash \kind_1 \subkind \kGuard{\constr}\kind_2
}
$$
Note that there is no structural subkinding rule for guarded kinds like
$$
\inference{\cEnv \vdash \kind_1 \subkind \kind_2}{
  \cEnv \vdash \kGuard{\constr} \kind_1 \subkind \kGuard{\constr} \kind_2
}[\ensuremath{\times}]
$$
Such a rule can be derived from both subkinding rules for guarded kind,
transitivity, and weakening.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Formulas}
Formulas include standard connectives (of kind $\kProp$):

\begin{tabular}{rrlr}
$\formphi$ & $::=$ & $\bot
               \bnfor \top
               \bnfor \formphi \vee \formphi
               \bnfor \formphi \wedge \formphi
               \bnfor \formphi \fImp \formphi
               \bnfor \ldots $ & (formulas)
\end{tabular}
\\ \\
Quantification over atoms and terms (on formulas of kind $\kProp$):

\begin{tabular}{rrlr}
$\formphi$ & $::=$ & $\ldots
               \bnfor \fForallAtom{\atomv} \formphi
               \bnfor \fForallTerm{\termv} \formphi
               \bnfor \fExistsAtom{\atomv} \formphi
               \bnfor \fExistsTerm{\termv} \formphi
               \bnfor \ldots$
    & (formulas)
\end{tabular}
\\ \\
Constraints, guards, and propositional variables:

\begin{tabular}{rrlr}
$\formphi$ & $::=$ & $\ldots
               \bnfor \fConstr{\constr}
               \bnfor \fCAnd{\constr} \formphi
               \bnfor \fCImp{\constr} \formphi
               \bnfor \propv
               \bnfor \ldots$  (formulas)
\end{tabular}
$$
\inference{
}{
  \cEnv; \kEnv \vdash \fConstr{\constr} \ofkind \kProp
}
\qquad
\inference{
  \cEnv,\constr; \kEnv \vdash \formphi \ofkind \kProp
}{
  \cEnv; \kEnv \vdash \fCAnd{\constr} \formphi \ofkind \kProp
}
\qquad
\inference{
  \cEnv,\constr; \kEnv \vdash \formphi \ofkind \kProp
}{
  \cEnv; \kEnv \vdash \fCImp{\constr} \formphi \ofkind \kProp
}
\qquad
\inference{
  (\propv \ofkind \kind) \in \kEnv
}{
  \cEnv; \kEnv \vdash  \propv \ofkind \kind
}
$$
Propositional variables, functions and applications:

\begin{tabular}{rrlr}
$\formphi$ & $::=$ & $\ldots
               \bnfor \fLamAtom{\atomv} \formphi
               \bnfor \fLamTerm{\termv} \formphi
               \bnfor \fLamForm{\propv}{\kind} \formphi
               \bnfor \formphi \fAppAtom{\atomexp}
               \bnfor \formphi \fAppTerm{\term}
               \bnfor \formphi \fApp \formphi
               \bnfor \ldots$
    & (formulas)
\end{tabular}
$$
\inference{
  \cEnv; \kEnv \vdash \formphi \ofkind \kind
}{
  \cEnv; \kEnv \vdash \fLamAtom{\atomv} \formphi \ofkind \kForallAtom{\atomv}\kind
}
\qquad
\inference{
  \cEnv; \kEnv \vdash \formphi \ofkind \kind
}{
  \cEnv; \kEnv \vdash \fLamTerm{\termv} \formphi \ofkind \kForallTerm{\termv}\kind
}
\qquad
\inference{
  \cEnv; \kEnv, \propv \ofkind \kind_1 \vdash \formphi \ofkind \kind_2
}{
  \cEnv; \kEnv \vdash \fLamForm{\propv}{\kind_1} \formphi \ofkind \kind_1 \karrow \kind_2
}
$$
$$
\inference{
  \cEnv;\kEnv\vdash \formphi \ofkind \kForallAtom{\atomv}\kind
}{
  \cEnv;\kEnv\vdash \formphi \fAppAtom{\atomexp} \ofkind \kind \subst{\atomv}{\atomexp}
}
\qquad
\inference{
  \cEnv;\kEnv\vdash \formphi \ofkind \kForallTerm{\termv}\kind
}{
  \cEnv;\kEnv\vdash \formphi \fAppTerm{\term} \ofkind \kind\subst{\termv}{\term}
}
\qquad
\inference{
  \cEnv; \kEnv \vdash \formphi_1 \ofkind \kind' \karrow \kind &
  \cEnv; \kEnv \vdash \formphi_2 \ofkind \kind'
}{
  \cEnv;\kEnv\vdash \formphi_1 \fApp \formphi_2 \ofkind \kind
}
$$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Fixpoint}
\newcommand{\fix}[3]{\ensuremath{\text{fix }#1(#2)\ofkind#3=}}
And finish the definition of formulas with \textit{fixpoint} function:

\begin{tabular}{rrlr}
$\formphi$ & $::=$ & $\ldots
               \bnfor \fix{\propv}{\termv}{\kind}{\formphi} $
    & (formulas)
\end{tabular}
$$
\inference{
  \cEnv;\kEnv, (\propv \ofkind \kForallTerm{\termv'} \kGuard{\termv' \cshlt \termv}{\kind\subst{\termv}{\termv'}})\vdash \formphi \ofkind \kind
}{
  \cEnv;\kEnv\vdash (\fix{\propv}{\termv}{\kind}{\formphi}) \ofkind \kForallTerm{\termv}{\kind}
}
$$
Fixpoint constructor allows us to express \textit{recursive} predicates over terms,
but only such that the recursive applications are on structurally smaller terms,
which we express in the kinding rule through the kinding $(\propv \ofkind \kForallTerm{\termv'} \kGuard{\termv' \cshlt \termv}{\kind\subst{\termv}{\termv'}})$.
To evaluate a fixpoint function applied on a term, simply substitute the bound
variable with given term and recursive calls inside fixpoint's body with the fixpoint itself.
$$
(\fix{\propv}{\termv}{\kind}{\formphi})\fApp\term
\equiv
\formphi\subst{\termv}{\term}\subst{\propv}{(\fix{\propv}{\termv}{\kind}{\formphi})}
$$
Because the applied term is finite and we always recurse on structurally smaller
terms, the final formula after all substitutions must also be finite ---
thanks to semantics of constraints and kinds.

To familiarize the reader with the fixpoint formulas we present
how peano arithmetic can be modeled in our logic.
Given symbols $0$ and $S$ for natural numbers construction one can write a
predicate that a term models some natural number:
$$
\fix{Nat}{N}{\kProp}{(N \ceq 0) \vee (\fExistsTerm{M} \fCAnd{N \ceq {S \tapp M}} {Nat}\fAppTerm{M})}
$$
Notice how the constraint $(N \ceq {S \tapp M})$ guards the recursive call to $Nat$,
ensuring that constraint $(M \cshlt N)$ will be satisfied during kind checking of
$({{Nat}\fAppTerm{M}})$ in the kind derivation of the whole formula
$({Nat} \ofkind \kForallTerm{N}{\kProp})$.

Similarly, we can define addition: \\ \\
$\fix{PlusEq}{N}{\kForallTerm{M}\kForallTerm{K}\kProp}{\fLamTerm{M}\fLamTerm{K}}$ \\
$\text{ }\qquad
  (\fCAnd{N \ceq 0}{M \ceq K}) \vee
   (\fExistsTerm{N', K'}\fCAnd{N \ceq {S \tapp N'}}\fCAnd{K \ceq {S \tapp K'}}{{PlusEq}\fApp{N'}\fApp{M}\fApp{K'}}
   )
$
\\
TODO: Write how $N$ is treated differently from $M$ and $K$?
\\
See more interesting examples of fixpoints usage in the chapter on STLC.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Proof theory}

\newcommand{\rel}[2][\Gamma;C]{\ensuremath{#1\vdash#2}}
\newcommand{\types}[3][\Gamma]{\rel[#1]{#2 : #3}}
\newcommand{\interp}[2][\tmEnv]{\left\llbracket {#2} \right\rrbracket_{#1}}
\newcommand{\arr}{\rightarrow }
% \newcommand{\inference}[2]{\inferrule{ #1}{#2}}
\newcommand{\all}[1][x]{\ensuremath{\forall #1.\:}}
\newcommand{\exi}[1][x]{\ensuremath{\exists #1.\:}}
\newcommand{\karr}{\Rightarrow }
\newcommand{\lam}[1][x]{\lambda{#1}.\;}
\newcommand{\jgmnt[2]}[\cEnv;\Theta]{\ensuremath{#1 \vdash #2}}
\newcommand{\cjgmnt[2]}[\cEnv]{\ensuremath{#1 \vDash #2}}
\newcommand{\fv[1]}[\cEnv;\Theta]{\ensuremath{\operatorname{FV}(#1)}}

Finally we can define proof-theoretic rules.
Starting with inference rules for assumption,
we can already define it's constraint-sublogic analogues that employ the solver.
And while the $\vdash$ relation we define is purely syntactic,
we can still use semantic $\vDash$ because of it's decidability.
$$
  \inference{
    \formphi \in \Theta
  }{
    \jgmnt[\cEnv;\Theta]{\formphi}
  }[(\ensuremath{Assumption})]
  \qquad
  \inference{
    \cjgmnt[\cEnv]{\constr}
  }{
    \jgmnt[\cEnv;\Theta]{\constr}
  }[(\ensuremath{constr^i})]
$$
Again for \textit{ex falso} we define constructor for dealing with contradictory
constraint evironment.
Note that there are many constraints that can be used as $\bot_\constr$, i.e.
constraints that are always false and solver will only \textit{prove} them
if we supply it with contradictory assumptions.
$$
  \inference{
    \jgmnt[\cEnv;\Theta]{\bot}
  }{
    \jgmnt[\cEnv;\Theta]{\formphi}
  }[(\ensuremath{\bot^e})]
  \qquad
  \inference{
    \cjgmnt[\cEnv]{\bot_\constr}
    }{
    \jgmnt[\cEnv;\Theta]{\formphi}
  }[(\ensuremath{constr^e})]
$$
Inference rules for implication are standard and the reason we present them here
is not to bore the reader but to point the similarities to their constraint analogues.
$$
  \inference{
    \jgmnt[\cEnv;\Theta,\formphi_1]{\formphi_2}
  }{
    \jgmnt[\cEnv;\Theta]{\formphi_1 \fImp \formphi_2}
  }[(\ensuremath{\fImp^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv_1;\Theta_1]{\formphi_1} &
    \jgmnt[\cEnv_2;\Theta_2]{\formphi_1 \fImp \formphi_2}
    }{
    \jgmnt[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]{\formphi_2}
  }[(\ensuremath{\fImp^e})]
$$
$$
  \inference{
    \jgmnt[\cEnv, \constr;\Theta]{\formphi}
  }{
    \jgmnt[\cEnv;\Theta]{\fCImp{\constr}\formphi}
  }[(\ensuremath{\fCImp{\cdot}^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv_1;\Theta_1]{\constr} &
    \jgmnt[\cEnv_2;\Theta_2]{\fCImp{\constr}\formphi}
    }{
    \jgmnt[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]{\formphi}
  }[(\ensuremath{\fCImp{\cdot}^e})]
$$
Notice that in the case constraint-and-guard the rule for elimination is restricted
to only formulas of kind $\kProp$.
This is due to nature of the guard --- if we want to eliminate it,
we can only do so with formulas that \textit{make sense} on their own,
without that $\constr$ guard.
$$
  \inference{
    \jgmnt[\cEnv_1;\Theta_1]{\formphi_1} &
    \jgmnt[\cEnv_2;\Theta_2]{\formphi_2}
  }{
    \jgmnt[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]{\formphi_1 \wedge \formphi_2}
  }[(\ensuremath{\wedge^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi_1 \wedge \formphi_2}
    }{
    \jgmnt[\cEnv;\Theta]{\formphi_1}
  }[(\ensuremath{\wedge^e_1})]\qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi_1 \wedge \formphi_2}
    }{
    \jgmnt[\cEnv;\Theta]{\formphi_2}
  }[(\ensuremath{\wedge^e_2})]
$$
$$
  \inference{
    \cjgmnt[\cEnv]{\constr} &
    \jgmnt[\cEnv, \constr;\Theta]{\formphi}
  }{
    \jgmnt[\cEnv;\Theta]{\fCAnd{\constr}\formphi}
  }[(\ensuremath{\fCAnd{\cdot}^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\fCAnd{\constr}\formphi}
    }{
    \jgmnt[\cEnv;\Theta]{\constr}
  }[(\ensuremath{\fCAnd{\cdot}^e_1})]\qquad
  \inference{
    \jgmnt[\cEnv]{\fCAnd{\constr}\formphi} &
    \jgmnt[\cEnv;\Theta]{\formphi: \kProp}
    }{
    \jgmnt[\cEnv;\Theta]{\formphi}
  }[(\ensuremath{\fCAnd{\cdot}^e_2})]
$$
Inference rules for disjunction and quantifier are rather straightforward.
As one would expect we restrict generalized name to be \textit{fresh} in the enviroment (it may not occur in any of the assumptions)
and the names given to witnesses of existentential quantification must also be \textit{fresh}.
Rules for quantifiers always come in pairs --- one for the atoms and one for the variables.
$$
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi_1}
    }{
    \jgmnt[\cEnv;\Theta]{\formphi_1 \vee \formphi_2}
  }[(\ensuremath{\vee^i_1})]
  \qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi_2}
  }{
    \jgmnt[\cEnv;\Theta]{\formphi_1 \vee \formphi_2}
  }[(\ensuremath{\vee^i_2})]
  \qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi_1 \vee \formphi_2} \\
    \jgmnt[\cEnv;\Theta,\formphi_1]{\psi} &
    \jgmnt[\cEnv;\Theta,\formphi_2]{\psi}
  }{
    \jgmnt[\cEnv;\Theta]{\psi}
  }[(\ensuremath{\vee^e})]
$$
$$
  \inference{
    \atomv \notin \fv[\cEnv;\Theta] &
    \jgmnt[\cEnv;\Theta]{\formphi}
  }{
    \jgmnt[\cEnv;\Theta]{\fForallAtom{\atomv}\formphi}
  }[(\ensuremath{{\fForallAtom{}}^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\fForallAtom{\atomv}\formphi}
  }{
    \jgmnt[\cEnv;\Theta]{\formphi \{\atomv \mapsto \atomv'\}}
  }[(\ensuremath{{\fForallAtom{}}^e})]
$$
$$
  \inference{
    \termv \notin \fv[\cEnv;\Theta] &
    \jgmnt[\cEnv;\Theta]{\formphi}
  }{
    \jgmnt[\cEnv;\Theta]{\fForallTerm{\termv}\formphi}
  }[(\ensuremath{{\fForallTerm{}}^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\fForallTerm{\termv}\formphi}
  }{
    \jgmnt[\cEnv;\Theta]{\formphi \{\termv \mapsto \termv'\}}
  }[(\ensuremath{{\fForallTerm{}}^e})]
$$
$$
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi \{\atomv \mapsto \atomv'\}}
    }{
    \jgmnt[\cEnv;\Theta]{\fExistsAtom{\atomv}\formphi}
  }[(\ensuremath{{\fExistsAtom{}}^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv_1;\Theta_1]{\fExistsAtom{\atomv}\formphi} \\
    \jgmnt[\cEnv_2;\Theta_2,\formphi \{\atomv \mapsto \atomv'\}]{\psi} \\
    \atomv' \notin \fv[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]
    }{
    \jgmnt[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]{\psi}
  }[(\ensuremath{{\fExistsAtom{}}^e})]
$$
$$
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi \{\termv \mapsto \termv'\}}
    }{
    \jgmnt[\cEnv;\Theta]{\fExistsTerm{\termv}\formphi}
  }[(\ensuremath{{\fExistsTerm{}}^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv_1;\Theta_1]{\fExistsTerm{\termv}\formphi} \\
    \jgmnt[\cEnv_2;\Theta_2,\formphi \{\termv \mapsto \termv'\}]{\psi} \\
    \termv' \notin \fv[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]
    }{
    \jgmnt[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]{\psi}
  }[(\ensuremath{{\fExistsTerm{}}^e})]
$$
To make the framework more flexible we introduce a way for using equivalent formulas:
$$
  \inference{
    \jgmnt[\cEnv;\Theta]{\psi} &
    \jgmnt[\cEnv;\Theta]{\psi \equiv \formphi}
    }{
    \jgmnt[\cEnv;\Theta]{\formphi}
  }[(\ensuremath{Equiv})]
$$
And a way to substitute atoms for atomic expression and variables for terms, if the solver can prove their equality:
$$
  \inference{
    \cjgmnt[\cEnv]{\atomv \ceq \atomexp} &
    \jgmnt[\cEnv;\Theta]{\formphi}
    }{
    \jgmnt[\cEnv\{\atomv \mapsto \atomexp\};\Theta\{\atomv \mapsto \atomexp\}]{\formphi\{\atomv \mapsto \atomexp\}}
  }[(\ensuremath{\mapsto_A})]
\qquad
  \inference{
    \cjgmnt[\cEnv]{\termv \ceq \term} &
    \jgmnt[\cEnv;\Theta]{\formphi}
    }{
    \jgmnt[\cEnv\{\termv \mapsto \term\};\Theta\{\termv \mapsto \term\}]{\formphi\{\termv \mapsto \term\}}
  }[(\ensuremath{\mapsto_T})]
$$
Finall we define induction over term structure,
and thanks to the constraints sublogic we can easily define the notion of
\textit{smaller terms} for inductive hypothesis:
$$
  \inference{
    \jgmnt[\cEnv;\Theta, (\fForallTerm{\termv'} \fCImp{\termv' \cshlt \termv} \formphi(\termv'))]{\formphi(\termv)}
    }{
    \jgmnt[\cEnv;\Theta]{\fForallTerm{\termv} \formphi(\termv)}
  }[(\ensuremath{Induction})]
$$
We also define some axioms about constraint sublogic:
\begin{enumerate}
\item Atoms can be compared in a deterministic fashion,
$$
  \inference{
    }{
    \jgmnt[]{\fForallAtom{\:\atomv,\:\atomv'} (\atomv \ceq \atomv') \vee (\atomv \cneq \atomv')}
  }[(\ensuremath{Axiom_{Compare}})]
$$
\item There are always exists a \textit{fresh} atom,
$$
  \inference{
    }{
    \jgmnt[]{\fForallTerm{\termv} \:\fExistsAtom{\atomv} (\atomv \cfresh \termv)}
  }[(\ensuremath{Axiom_{Fresh}})]
$$
\item We can deduce the structure of a term.
\begin{eqnarray*}
  & \inference{
    }{
    \jgmnt[]{\fForallTerm{\termv} (\fExistsAtom{\atomv}\: \termv = \atomv) \vee (\fExistsAtom{\atomv}\:\fExistsTerm{\termv'}\: \termv = \tbind{\atomv}{\termv'}) }
  }[(\ensuremath{Axiom_{Inversion}})] \\
  & \ensuremath{\vee (\fExistsTerm{\termv_1,\:\termv_2}\: \termv = \tbind{\atomv}{\termv'}) \vee ({symbol}\: \termv) } \\
\end{eqnarray*}
\end{enumerate}

The equivalence relation ($\formphi_1 \equiv \formphi_2$) is a bit complicated
due to the presence of evironment with variable mapping, subkinding and formulas
with fixpoints, functions, and applications.
Nonetheless, it's simply that - \textit{an equvialence relation} - and it
behaves as expected. We will only highlighting the interesting parts.
$$
  \inference{
    \jgmnt[\Gamma; \Sigma]{\formphi_1[\termv_1 \mapsto  \term_1] \equiv \formphi_2[\termv_2 \mapsto \term_2] }
    }{
    \jgmnt[\Gamma; \Sigma]{(\fLamTerm{\termv_1}\formphi_1) \fAppTerm \term_1 \equiv (\fLamTerm{\termv_2}\formphi_2) \fAppTerm \term_2}
  }
$$
Otherwise we compute weak head normal form (up to some \textit{depth}) and recurse on subformulas:
$$
  \inference{
    \jgmnt[\Gamma; \Sigma; S n]{(\fix{P}{\termv}{\kind}\formphi) \fAppTerm \term}
    }{
    \jgmnt[\Gamma; \Sigma, P \mapsto \formphi; n]{\formphi[\termv \mapsto \term]}
  }
$$
Until we reach WHNF computation \textit{depth} or cannot compute the formula further,
we resort to \textit{naive} checking:
$$
  \inference{
    \cjgmnt[\Gamma]{\term_1 \ceq \term_2} &
    \jgmnt[\Gamma; \Sigma]{\formphi_1 \equiv \formphi_2 }
    }{
    \jgmnt[\Gamma; \Sigma]{\formphi_1 \fAppTerm \term_1 \equiv \formphi_2 \fAppTerm \term_2 }
  }
$$
$$
  \inference{
    \termv \notin \fv[\Gamma; \Sigma] \\
    \jgmnt[\Gamma; \Sigma]{\formphi_1[\termv_1 \mapsto \termv] \equiv \formphi_2[\termv_2 \mapsto \termv] }
    }{
    \jgmnt[\Gamma; \Sigma]{\fLamTerm{\termv_1}\formphi_1 \equiv \fLamTerm{\termv_2}\formphi_2 }
  }
$$
$$
  \inference{
    \kind_1 \subkind \kind_2 \\
    \jgmnt[\Gamma; \Sigma]{\formphi_1[P_1 \mapsto P] \equiv \formphi_2[P_2 \mapsto P] }
    }{
    \jgmnt[\Gamma; \Sigma]{\fLamForm{P_1}{\kind_1}{\formphi_1} \equiv \fLamForm{P_2}{\kind_2}{\formphi_2}}
  }
$$
$$
  \inference{
    \kind_1 \subkind \kind_2 &
    P \notin \fv[\Gamma; \Sigma] & \termv \notin \fv[\Gamma; \Sigma] \\
    \jgmnt[\Gamma; \Sigma]{\formphi_1[P_1 \mapsto P, \termv_1 \mapsto \termv] \equiv \formphi_2[P_2 \mapsto P, \termv_2 \mapsto \termv] }
    }{
    \jgmnt[\Gamma; \Sigma]{\fix{P_1}{\termv_1}{\kind_1}\formphi_1 \equiv \fix{P_2}{\termv_2}{\kind_2}\formphi_2}
  }
$$
Note that we allow \textit{different terms} in equivalent formulas as long as
constraints-enviroment $\cEnv$ ensures their equality is provable.
Quantifiers are handled the same way as function above --- as they all a form of bind.
\begin{eqnarray*}
  \inference{
    \jgmnt[\Gamma]{\constr_1 \equiv \constr_2 } &
    \jgmnt[\Gamma; \Sigma]{\formphi_1 \equiv \formphi_2 }
  }{
    \jgmnt[\Gamma; \Sigma]{\fCAnd{\constr_1}\formphi_1 \equiv \fCAnd{\constr_2}\formphi_2 }
  }
\qquad
  \inference{
    \cjgmnt[\Gamma]{\atomv_1 \ceq \atomv_2 } & \cjgmnt[\Gamma]{\term_1 \ceq \term_2 }
  }{
    \jgmnt[\Gamma]{(\atomv_1 \cfresh \term_1) \equiv (\atomv_2 \cfresh \term_2) }
  }
\end{eqnarray*}
To handle formulas with constraints we introduce constraint equivalence relation,
which does nothing more than use solver to check that arguments and constructors
of constraint are equal in the solver sense.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Model}

Definition of a model of our logic is bit involved,
due to presence of subkinding relation.
We will proceed in two steps.
First, for each kind $\kind$ we define its \emph{domain} $\kindDom{\kind}$.
Then we will interpret each kind as a predicate on elements of its domain.
We fix some Heyting algebra $\PropAlg$
in which we will interpret propositions.
Then kind domains are defined in the following way.
\begin{eqnarray*}
\kindDom{\kProp}                     & = & \PropAlg \\
\kindDom{\kind_1 \karrow \kind_2}    & = & \kindDom{\kind_1} \rightarrow \kindDom{\kind_2} \\
\kindDom{\kForallAtom{\atomv}\kind}  & = & \atomDom          \rightarrow \kindDom{\kind} \\
\kindDom{\kForallTerm{\termv}\kind}  & = & \termDom          \rightarrow \kindDom{\kind} \\
\kindDom{\kGuard{\constr}\kind}      & = & \kindDom{\kind}
\end{eqnarray*}

%%%%%%%%%%%%%%%%%%%%%%%
And kind interpretation like this:
\begin{eqnarray*}
\termMdl{\kProp}{\tmEnv}                      & = & \{ \bot, \top \} \\
\termMdl{\kind_1 \karrow \kind_2}{\tmEnv}     & = & \{f \mid \forall P \in \termMdl{\kind_1}{\tmEnv}.\: f(P) \in \termMdl{\kind_2}{\tmEnv} \} \\
\termMdl{\kForallAtom{\atomv}\kind}{\tmEnv}   & = & \{f \mid \forall A \in \atomDom.\: f(A) \in \termMdl{\kind}{\tmEnv[\atomv \mapsto A]}\} \\
\termMdl{\kForallTerm{\termv}\kind}{\tmEnv}   & = & \{f \mid \forall T \in \termDom.\: f(T) \in \termMdl{\kind}{\tmEnv[\termv \mapsto T]}\} \\
\termMdl{\kGuard{\constr}\kind}{\tmEnv}       & = & \{x \mid \tmEnv \vDash \constr \implies x \in \termMdl{\kind}{\tmEnv} \}
\end{eqnarray*}



And finally the kind derivation model:
\begin{eqnarray*}
\interp{\inferrule{ }{\types{\top}{\kProp}}} & = & \top \\
\interp{\inference{ }{\types{ \propv}{\Gamma( \propv)}}} & = & \tmEnv(\propv) \\
    \interp{\inference{}{\types{\constr}{\kProp}}} & = & \texttt{if } \tmEnv \vDash \constr \texttt{ then } \top \texttt{ else } \bot
\end{eqnarray*}

\begin{eqnarray*}
    \interp{
        \inference{D_1 : \types{\formphi_1 }{\kProp} \\ D_2 : \types{\formphi_2 }{\kProp}
    }{
        \types{\formphi_1 \wedge \formphi_2}{\kProp}}
    } & = & \interp{D_1} \wedge_\PropAlg \interp{D_2} \\
    \interp{
        \inference{D_1 : \types{\formphi_1 }{\kProp}  \\ D_2 : \types{\formphi_2 }{\kProp}
    }{
        \types{\formphi_1 \vee \formphi_2}{\kProp}}
    } & = & \interp{D_1} \vee_\PropAlg \interp{D_2} \\
    \interp{
        \inference{D_1 : \types{\formphi_1 }{\kProp}  \\ D_2 : \types{\formphi_2 }{\kProp}
    }{
        \types{\formphi_1 \Rightarrow \formphi_2}{\kProp}}
    } & = & \interp{D_1} \Rightarrow_\PropAlg \interp{D_2}
\end{eqnarray*}

\begin{eqnarray*}
    \interp{
        \inference{D : \types{\formphi}{\kProp}
    }{
        \types{\fForallTerm{\termv}\formphi}{\kProp}}
    } & = & \underset{T \in Term}{\bigwedge} {\interp[{\tmEnv [\termv \mapsto T]}]{D}}  \\
    \interp{
        \inference{D : \types{\formphi}{\kProp}
    }{
        \types{\fForallAtom{\atomv}\formphi}{\kProp}}
    } & = & \underset{A \in Atom}{\bigwedge} {\interp[{\tmEnv [\atomv \mapsto A]}]{D}} \\
    \interp{
        \inference{D : \types{\formphi}{\kProp}
    }{
        \types{\fExistsTerm{\termv} \formphi}{\kProp}}
    } & = & \underset{T \in Term}{\bigvee}\interp[{\tmEnv [\termv \mapsto T]}]{D} \\
    \interp{
        \inference{D : \types{\formphi}{\kProp}
    }{
        \types{\fExistsAtom{\atomv} \formphi}{\kProp}}
    } & = & \underset{A \in Atom}{\bigvee} \interp[{\tmEnv [\atomv \mapsto A]}]{D}
\end{eqnarray*}

\begin{eqnarray*}
   \interp{
        \inference{D : \types[\Gamma, c]{\formphi}{\kProp}
    }{
        \types{[c] \wedge \formphi}{\kProp}}
    } & = &  \texttt{if } \tmEnv \vDash c \texttt{ then } \interp{D} \texttt{ else } \bot
    \\
    \interp{
        \inference{D : \types[\Gamma, c]{\formphi}{\kProp}
    }{
        \types{[c] \Rightarrow \formphi}{\kProp}}
    } & = &  \texttt{if } \tmEnv \vDash c \texttt{ then } \interp{D} \texttt{ else } \top
\end{eqnarray*}

\begin{eqnarray*}
    \interp{\inference{D : \types{\formphi}{\kind_2}}{\types{\lam[\propv]\formphi}{\kind_1\karr\kind_2}}} & = &
    \lambda\;(Q : \interp{\kind_1}).\;\interp[{\tmEnv[\propv\mapsto Q]}]{D}
    \\
    \interp{\inference{D: \types{\formphi}{\kind}}{\types{\lam[\atomv]\formphi}{\kForallAtom{\atomv}\kind}}} & = &
    \lambda\;(A : Atom).\;\interp[{\tmEnv[\atomv\mapsto A]}]{D}
    \\
    \interp{\inference{D: \types{\formphi}{\kind}}{\types{\lam[\termv]\formphi}{\kForallTerm{\termv}\kind}}} & = &
    \lambda\;(T : Term).\;\interp[{\tmEnv[\termv\mapsto T]}]{D}
\end{eqnarray*}

\begin{eqnarray*}
    \interp{\inference{D_1: \types{\formphi_1}{\kind'\karr\kind} \\ D_2: \types{\formphi_2}{\kind'}}{\types{\formphi_1\;\formphi_2}{\kind}}} & = &
    \interp{D_1}\; \interp{D_2}
    \\
    \interp{\inference{D: \types{\formphi}{\kForallAtom{\atomv}\kind}}{\types{\formphi(\atomexp)}{\kind\{\atomv \mapsto \atomexp\}}}} & = &
    \interp{D}\;\interp{\atomexp}
    \\
    \interp{\inference{D: \types{\formphi}{\kForallTerm{\termv}\kind}}{\types{\formphi(\term)}{\kind\{\termv \mapsto \term\}}}} & = &
    \interp{D}\;\interp{\termv}
\end{eqnarray*}

%  lim w sensie tw kleenego o fixpoincie
\begin{eqnarray*}
    \interp{\inference{
            D : \types[{\Gamma, X : {\all[z]{[z < \termv']}}\;\kind\subst{z}{\termv'}}]\formphi\kind
        }{
            \types{\fix{X}{\termv'}\formphi}{\all[\termv']\kind}
        }} & = & \lim_{n \rightarrow \infty} f_n
    \\
    & & \texttt{ where } f_0(t) = \bot \\
    & & \texttt{ and } f_{n+1}(t) = \interp[{\tmEnv[X\mapsto f_n, \termv' \mapsto t]}]{D} \\
    \interp{\inference{
            D : \types[\Gamma, c]\formphi\kind
        }{
            \types{\formphi}{[c]\kind}
        }} & = & \texttt{if } \tmEnv \vDash c \texttt{ then } \interp{D} \texttt{ else } \text{''}\bot\text{''}
    \\
    \interp{\inference{
            D : \types\formphi\kind \\
            \rel[\Gamma] \kind \leq \kind'
        }{
            \types{\formphi}{\kind'}
        }} & = &  \interp{D}
\end{eqnarray*}

\section{Fundamental Theorem}
For any formula $\formphi$, any kind $\kind$, and any environment $\Gamma$, for any kind derivation $D : \types\formphi\kind$ under any interpretation $\tmEnv \in \interp[]{\Gamma}$, we have that
$$
    \interp{D} \in \interp{\kind}
$$
In other words, each kind derivation $D$ has a semantic witness that inhabits the semantic interpretation of $\kind$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Proof assistant}

\dots

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Case study: Progress and Preservation of STLC}

\dots

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion and future work}

\dots

%%%%% BIBLIOGRAFIA

\begin{thebibliography}{1}
\bibitem{example} \ldots
\end{thebibliography}

\end{document}
