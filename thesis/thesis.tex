% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk oraz rodzaj (lic/inz/mgr) pracy.
\documentclass[english, mgr]{iithesis}

\usepackage[utf8]{inputenc}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\englishtitle   {Nominal logic \fmlinebreak for reasoning about terms \fmlinebreak with variable bindings}
\polishtitle    {Logika dziedzinowa do wnioskowania \fmlinebreak o termach z wiązaniem zmiennych}
\polishabstract {Przedstawiamy logikę dziedzinową do wnioskowania o termach z wiązaniem zmiennych. }
\englishabstract{We describe logic for reasoning about terms with variable bindings.}
\author         {Dominik Gulczyński}
\advisor        {dr Piotr Polesiuk}
\date           {\today}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
\transcriptnum  {299391}                     % Numer indeksu
\advisorgen     {dr. Piotra Polesiuka} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd} % For \llbracket
\usepackage{macros}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{semantic}
\usepackage{sourcecodepro}
\usepackage{enumitem}

%%%%% WŁASNE DEFINICJE I POLECENIA
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{ocamlstyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=ocamlstyle}
\lstdefinelanguage{OCaml}[]{caml}{
    morekeywords={val, ProofEnv}
}
\setlist{nolistsep}
\renewcommand{\tt}[1]{\texttt{\small{#1}}}
\renewcommand{\it}[1]{\textit{#1}}
%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}

\section{Problem statement}
\dots

\section{Motivation}
% Przykłady machania rękoma nad wiązaniem zmiennych w innych tekstach jako motywacja do tej pracy
\dots

\section{Related work}
\subsection{Nominal logics \& permutations}

\section{Contributions}
\dots

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Terms and constraints}
% Okreli odbiorce i do niego pisa

In classical first-order logic, terms are constructed from variables and applications of functional symbols to other terms. This work introduces an extension to terms with expressions closely resembling the syntax of lambda calculus. The aim is to create a flexible framework for reasoning about the lambda calculus and its derivations.

To achieve this goal, we introduce an infinite set of \it{atoms} (represented by lowercase letters) which correspond to the bound variables in terms, analogous to the variables in lambda calculus. This set is disjoint from the set of variables commonly used in first-order logic, which we will refer to as \it{variables} (denoted by uppercase letters).

Terms are defined by the following grammar:
\\
\begin{tabular}{rclr}
    $\perm$    & $\deff$ & $\permid \mid \permswap{\atomexp}{\atomexp}{\perm}$ \\
    $\atomexp$ & $\deff$ & $\perm \apperm \atomv$ \\
    $\term$    & $\deff$ & $\atomexp \mid \perm \apperm \termv \mid \tbind{\atomexp} \term \mid \term \tapp \term \mid \symb$
\end{tabular}
\\

It's important to note that terms do not inherently incorporate notions of computation, reduction, or binding. These expressions closely resemble lambda calculus syntax but lack its operational semantics. However, the intuitions associated with these expressions are not baseless. Their practical application is observed in the sublogic of constraints defined on top of terms, used to reason about concepts such as \it{freshness}, \it{variable binding}, and \it{structural} order, as well as their logical model.

Constraints are given by the following grammar:
\\
\begin{tabular}{rclr}
    $\constr$  & $\deff$ & $\atomexp \cfresh \term
                   \bnfor \term \ceq \term
                   \bnfor \term \csheq \term
                   \bnfor \term \cshlt \term$
        & (constraints)
\end{tabular}
\\
with following semantics:
\begin{eqnarray*}
  \atomexp \cfresh \term & \text{---} & \text{
    atom $\atomexp$ is {Fresh} in term $\term$, i.e. does not occur in $\term$
    as a free variable
  } \\
  \term_1 \ceq \term_2 & \text{---} &\text{
    terms $\term_1$ and $\term_2$ are alpha-equivalent
  } \\
  \term_1 \csheq \term_2 & \text{---} &\text{
    terms $\term_1$ and $\term_2$ possess an identical shape,
  } \\
  & & \text{
    i.e. after erasing all atoms, terms $\term_1$ and $\term_2$ would be equal
  } \\
  \term_1 \cshlt \term_2 & \text{---} &\text{
    shape of term $\term_1$ is structurally smaller than the shape of term
    $\term_2$,
  } \\
  & & \text{
    i.e. after erasing all atoms $\term_1$ would be equal to some
    subterm of $\term_2$
  } \\
\end{eqnarray*}

We use metavariable $\cEnv$ to represent finite sets of constraints.


\begin{tabular}{rclr}
$\semterm$ & $\deff$ & $\sematom
               \bnfor n
               \bnfor \stbind \semterm
               \bnfor \semterm \stapp \semterm
               \bnfor \symb$
    & (semantic terms) \\
$\shape$   & $\deff$ & $\shatom
               \bnfor \shbind \shape
               \bnfor \shape \shapp \shape
               \bnfor \symb$
    & (semantic shapes)
\end{tabular}

\begin{eqnarray*}
  \termMdl{\perm \apperm \atomv}{\tmEnv} & = &
    \permMdl{\perm}{\tmEnv}(\tmEnv(\atomv)) \\
  \termMdl{\perm \apperm \termv}{\tmEnv} & = &
    \permMdl{\perm}{\tmEnv}(\tmEnv(\termv)) \\
  \termMdl{\tbind{\atomexp} \term}{\tmEnv} & = &
    \stbind (\termMdl{\term}{\tmEnv} \shiftIdx)
      \subst{\termMdl{\atomexp}{\tmEnv}}{0} \\
  \termMdl{\term_1 \tapp \term_2}{\tmEnv} & = &
    \termMdl{\term_1}{\tmEnv} \stapp \termMdl{\term_2}{\tmEnv} \\
  \termMdl{\symb}{\tmEnv} & = & \symb
\end{eqnarray*}

\begin{eqnarray*}
  \shapeof{\sematom}                     & = & \shatom \\
  \shapeof{n}                            & = & \shatom \\
  \shapeof{\stbind \semterm}             & = & \shbind \shapeof{\semterm} \\1
  \shapeof{\semterm_1 \stapp \semterm_2} & = &
    \shapeof{\semterm_1} \shapp \shapeof{\semterm_2}
\end{eqnarray*}

\begin{eqnarray*}
  \tmEnv \vDash \term_1 \ceq \term_2 & \textrm{iff} &
    \termMdl{\term_1}{\tmEnv} = \termMdl{\term_2}{\tmEnv} \\
  \tmEnv \vDash \atomexp \cfresh \term & \textrm{iff} &
    \termMdl{\atomexp}{\tmEnv} \notin
      \mathsf{FreeAtoms}(\termMdl{\term}{\tmEnv}) \\
  \tmEnv \vDash \term_1 \csheq \term_2 & \textrm{iff} &
    \shapeof{\termMdl{\term_1}{\tmEnv}} = \shapeof{\termMdl{\term_2}{\tmEnv}} \\
  \tmEnv \vDash \term_1 \cshlt \term_2 & \textrm{iff} &
    \shapeof{\termMdl{\term_1}{\tmEnv}} \textrm{ is a strict subshape of }
      \shapeof{\termMdl{\term_2}{\tmEnv}}
\end{eqnarray*}

We write $\tmEnv \vDash \cEnv$ iff for all $\constr \in \cEnv$,
we have $\tmEnv \vDash \constr$.
We write $\cEnv \vDash \constr$ iff
for every $\tmEnv$ such that $\tmEnv \vDash \cEnv$,
we have $\tmEnv \vDash \constr$.

Within this model, we establish the existence of a decidible algorithm for determining whether $C_1, \ldots, C_n \models C_0$, meaning there is a deterministic way to check whether constraints $C_1, \ldots, C_n$ imply $C_0$. This algorithm is presented in the following chapter.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Constraint solver}
At the heart of our work lies the Solver, an algorithm designed to resolve constraints.
A high level perspective of the Solver is that it dissects constraints on both sides of the turnstile into irreducible components that are solved easily.

Given a set of assumptions $\constr_1, \dots, \constr_n$, it verifies whether a given goal $\constr_0$ holds.
Technically, the Solver determines whether,
every possible substitution of variables into closed terms in $\constr_0, \constr_1, \dots, \constr_n$,
such that $\constr_1, \dots, \constr_n$ are satisfied, will also satisfy $\constr_0$.

For the sake of convenience and implementation efficiency, the Solver operates
on slightly different constraints compared to those found in formulas and kinds.
The key distinction lies in the use of \it{shapes} in shape constraints rather than terms.

Solver constraints and shapes are defined by the following grammar: \\
\begin{tabular}{rclr}
  $\sconstr$ & $\deff$ & $\atomexp \cfresh \term
  \bnfor \term \ceq \term
  \bnfor \shape \csheq \shape
  \bnfor \shape \cshlt \shape$
      & (solver constraints) \\
  $\shape$      & $\deff$ & $\shatom
                 \bnfor  \termv
                 \bnfor \shbind \shape
                 \bnfor \shape \tapp \shape
                 \bnfor \symb$
      & (shapes)
\end{tabular}\\
Solver erases atoms from terms in shape constraints,
effectively transforming them from \it{constraints} to \it{solver constraints}.

We add another environment $\icEnv$ to distinguish between the potentially-reducible assumptions in $\cEnv$.
For convenience, we will write $\atomv \cneq \atomexp$ instead of $\atomv \cfresh \atomexp$ as it gives a clear intuition of atom freshness implying inequality.
Additionally, when $\atomexp = \pi \atomv$, we will denote $\atomexp \cfresh \term$ to mean $\atomv \cfresh \pi^{-1} \term$.

Irreducible constraints are:
\begin{eqnarray*}
  \atomv_1 \cneq \atomv_2 & \text{---} & \text{
    atoms $\atomv_1$ and $\atomv_2$ are different
  } \\
  \atomv   \cfresh \termv   & \text{---} & \text{
    atom $\atomv$ is {Fresh} in variable $\termv$
  } \\
  \termv_1 \csheq  \termv_2 & \text{---} & \text{
    variables $\termv_1$ and $\termv_2$ posses the same shape
  } \\
  \termv   \csheq  \term    & \text{---} & \text{
    variable $\termv$ has a shape of term $\term$
  } \\
  \term    \cshlt  \termv   & \text{---} & \text{
    term $\term$ strictly subshapes variable $\termv$
  } \\
\end{eqnarray*}

After all the constraints are reduced to such simple constraints
we reduce the goal-constraint and repeat the reduction procedure on
new assumptions and goal. We either arrive at a contradictory environment or
all the assumptions and goal itself are reduced to irreducible constraints, which
is as simple as checking if the goal occurs on the left side of the turnstile:
$$
\inferrule{
  \inferrule{
    \sconstr'' \in \icEnv''
    }{
    \inferrule{
     \cdots
    }{
     \cEnv' ; \icEnv' \vDash \sconstr' \\ \cdots
  }
  }
}{
  \cEnv ; \icEnv \vDash \sconstr
}
$$
And now for the solving procedure we start with the most simple equality check:
$$\inferrule{
}{
  \cEnv ; \icEnv \vDash \atomv = \atomv
}
\qquad
\inferrule{
}{
  \cEnv ; \icEnv \vDash \termv = \termv
}
\qquad
\inferrule{
}{
  \cEnv ; \icEnv \vDash \symb = \symb
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \term_1 = \term_2
  \\
  \cEnv ; \icEnv \vDash \term_1' = \term_2'
}{
  \cEnv ; \icEnv \vDash \term_1 \term_1' = \term_2 \term_2'
}
$$
Checking equality of abstraction terms requires that the left side's argument is
fresh in the whole right side's term (either arguments are the same or left's argument doesn't occur in right's body)
and that left body is equal to the right body with right argument swapped for the left one:
$$
\inferrule{
  \cEnv ; \icEnv \vDash \atomexp_1 \cfresh \tbind{\atomexp_2}\term_2
  \\
  \cEnv ; \icEnv \vDash \term_1 = \permswap{\atomexp_1}{\atomexp_2} \term_2
}{
  \cEnv ; \icEnv \vDash \tbind{\atomexp_1} \term_1 = \tbind{\atomexp_2} \term_2
}
$$

To compare a \it{pure} atom with permuted one, we employ the decidability of
atom equality to strip the right hand-side permutation through applying the
outermost swap on the left side, while adding to assumption.
There's three possible ways: \begin{enumerate}[noitemsep]
    \item $\atomv$ is different from both $\atomexp_1$ and $\atomexp_2$,
so the swap doesn't change the goal,
    \item $\atomv$ is equal to $\atomexp_1$ but different from $\atomexp_2$,
so the swap substitutes it for $\atomexp_2$,
    \item $\atomv$ is equal to $\atomexp_2$,
so the swap substitutes it for $\atomexp_1$.
\end{enumerate}
Notice that it is impossible for any two of these assumption to be valid at the same time ---
the contradictory branches will resolve through absurd environment.
$$
\inferrule{
  \atomv \cneq \atomexp_1, \atomv \cneq \atomexp_2, \cEnv ; \icEnv \vDash \atomv     = \atomexp \\
  \atomv \ceq  \atomexp_1, \atomv \cneq \atomexp_2, \cEnv ; \icEnv \vDash \atomexp_2 = \atomexp \\
  \atomv \ceq  \atomexp_2, \cEnv ; \icEnv \vDash \atomexp_1 = \atomexp
}{
  \cEnv ; \icEnv \vDash \atomv = \permswap{\atomexp_1}{\atomexp_2}{\atomexp}
}
$$

If the left-hand side's term is permuted we simply move the permutation to the right-hand side:
$$
\inferrule{
  \cEnv ; \icEnv \vDash \atomv = \perm^{-1} \atomexp
}{
  \cEnv ; \icEnv \vDash \perm \atomv = \atomexp
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \termv_1 = \pi_1^{-1} \pi_2 \termv_2
}{
  \cEnv ; \icEnv \vDash \pi_1 \termv_1 = \pi_2 \termv_2
}
$$
Variables can be equal to their permuted selves if that permutation is idempotent:
$$
\inferrule{
  \cEnv ; \icEnv \vDash \pi \text{ idempotent on } \termv
}{
  \cEnv ; \icEnv \vDash \termv = \pi \termv
}
\qquad
\inferrule{
  \forall \atomv \in \pi.\;
    \cEnv ; \icEnv \vDash \atomv = \pi \atomv \;\vee\;
    \cEnv ; \icEnv \vDash \atomv \cfresh \termv
  }{
  \cEnv ; \icEnv \vDash \pi \text{ idempotent on } \termv
}
$$
\\
Freshness is checked through the $\icEnv$ environment and freshness in symbols is trivial:
$$\inferrule{
  \atomv_1 \cneq \atomv_2 \in \icEnv
}{
  \cEnv ; \icEnv \vDash \atomv_1 \cfresh \atomv_2
}
\qquad
\inferrule{
  \atomv \cfresh \termv \in \icEnv
}{
  \cEnv ; \icEnv \vDash \atomv \cfresh \termv
}
\qquad
\inferrule{
}{
  \cEnv ; \icEnv \vDash \atomv \cfresh \symb
}
$$
Similarly we recurse on the term structure, assuming checked atom is different than abstraction argument --- otherwise it would be trivially true:
$$\inferrule{
  \atomv \cneq \atomexp, \cEnv ; \icEnv \vDash \atomv \cfresh \term
}{
  \cEnv ; \icEnv \vDash \atomv \cfresh \tbind{\atomexp}{\term}
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \atomv \cfresh \term_1 \\
  \cEnv ; \icEnv \vDash \atomv \cfresh \term_2
}{
  \cEnv ; \icEnv \vDash \atomv \cfresh \term_1 \term_2
}
$$
Again when faced with swap on the right side, we apply it on the left side:
$$
\inferrule{
  \atomv \cneq \atomexp_1, \atomv \cneq \atomexp_2, \cEnv ; \icEnv \vDash \atomv     \cfresh \atomexp \\
  \atomv \ceq  \atomexp_1, \atomv \cneq \atomexp_2, \cEnv ; \icEnv \vDash \atomexp_1 \cfresh \atomexp \\
                          \atomv \ceq  \atomexp_2 , \cEnv ; \icEnv \vDash \atomexp_2 \cfresh \atomexp
}{
  \cEnv ; \icEnv \vDash \atomv \cfresh \permswap{\atomexp_1}{\atomexp_2}{} \atomexp
}
$$
$$
\inferrule{
  \atomv \cneq \atomexp_1, \atomv \cneq \atomexp_2, \cEnv ; \icEnv \vDash \atomv     \cfresh \pi \termv \\
  \atomv \ceq  \atomexp_1, \atomv \cneq \atomexp_2, \cEnv ; \icEnv \vDash \atomexp_1 \cfresh \pi \termv \\
                          \atomv \ceq  \atomexp_2 , \cEnv ; \icEnv \vDash \atomexp_2 \cfresh \pi \termv
}{
  \cEnv ; \icEnv \vDash \atomv \cfresh \permswap{\atomexp_1}{\atomexp_2}{\pi} \termv
}
$$
\\
All atoms have the same shape, while only equal symbols have equal shape:
$$
\inferrule{
}{
  \cEnv ; \icEnv \vDash \shatom \csheq \shatom
}
\qquad
\inferrule{
}{
  \cEnv ; \icEnv \vDash \symb \csheq \symb
}
$$
Variables can share shape and be shape-substituted through $\icEnv$:
$$
\inferrule{
  \termv_1 \csheq \termv_2 \in \icEnv
}{
  \cEnv ; \icEnv \vDash \termv_1 \csheq \termv_2
}
\qquad
\inferrule{
  \termv  \csheq \shape' \in \icEnv \\
  \cEnv ; \icEnv \vDash \shape'  \csheq \shape
}{
  \cEnv ; \icEnv \vDash \termv  \csheq \shape
}
$$
Shape equality is naturally structural:
$$\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \csheq \shape_2
}{
  \cEnv ; \icEnv \vDash \shbind \shape_1 \csheq \shbind \shape_2
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \csheq \shape_2 \\
  \cEnv ; \icEnv \vDash \shape_1' \csheq \shape_2'
}{
  \cEnv ; \icEnv \vDash \shape_1 \shape_1' \csheq \shape_2 \shape_2'
}
$$
\\
Solving subshape recurses through right-hand side shape's structure to find a shape-equal sub-shape:
$$\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \csheq \shape_2
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shbind \shape_2
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shbind \shape_2
}
$$
$$\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \csheq \shape_2
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2 \shape_2'
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \csheq \shape_2'
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2 \shape_2'
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2 \shape_2'
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2'
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \shape_2 \shape_2'
}
$$
Environment $\icEnv$ keeps track of all shapes that  given variable subshapes:
$$\inferrule{
  \shape_2 \cshlt \termv \in \icEnv \\
  \cEnv ; \icEnv \vDash \shape_2 \csheq \termv
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \termv
}
\qquad
\inferrule{
  \shape_2 \cshlt \termv \in \icEnv \\
  \cEnv ; \icEnv \vDash \shape_2 \cshlt \termv
}{
  \cEnv ; \icEnv \vDash \shape_1 \cshlt \termv
}
$$
And that finishes solving rules that recurse on the goal.
In mathematical jargon, the Solver must first reduce all assumptions in the $\cEnv$ environment before it starts reducing the goal.
Luckily, most of the assumption reducing rules are similar to the goal reducing analogues.

For variables equal to some term,
we first deal with permutation by moving it to the right-hand side.
$$
\inferrule{
   \termv = \pi^{-1} \term, \cEnv ; \icEnv \ vDash \sconstr
}{
   \pi \termv = \term, \cEnv ; \icEnv \vDash \sconstr
}
$$
Once again, we consider the special case where a variable is equal to itself when permuted.
While the assumption of the permutation being idempotent might appear to multiply the number of assumptions exponentially based on the number of atoms in the given permutation,
it's worth noting that this number is unlikely to be very high, as permutations rarely consist of more than a few swaps.

In practice, the solver implementation will initially check whether the permutation is idempotent with an empty set of assumptions.
Only if this initial check fails, will it proceed to examine the permutation atom by atom.

$$
\inferrule{
  \pi \text{ idempotent on } \termv, \cEnv ; \icEnv \vDash \sconstr
}{
   \termv = \pi \termv, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
  \vDash \text{ idempotent on } \termv \\
  \cEnv ; \icEnv \vDash \sconstr
}{
   \pi \text{ idempotent on } \termv, \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  (\forall \atomv \in \pi.\;
    \cEnv ; \icEnv \vDash \atomv = \pi \atomv \;\vee\;
    \cEnv ; \icEnv \vDash \atomv \cfresh \termv), \cEnv ; \icEnv \vDash \sconstr
}{
\pi \text{ idempotent on } \termv, \cEnv ; \icEnv \vDash \sconstr
}
$$
\\
Otherwise we just substitute the variable for the equal term,
and while substitution over the environment $\cEnv$ and goal $\sconstr$ is indeed a simple term substitution, substituting in $\icEnv$ is a more involved process that we will describe in the section on implementation.
$$
\inferrule{
   \cEnv\subst{\termv}{\term} ; \icEnv\subst{\termv}{\term} \vDash \sconstr\subst{\termv}{\term}
}{
   \termv = \term, \cEnv ; \icEnv \vDash \sconstr
}
$$
With atom equality, we either arrive at a contradiction with $\icEnv$ or update the environment accordingly
--- merging the now equal atoms into one through substitution:
$$
\inferrule{
  \atomv_1 \cneq \atomv_2 \in \icEnv
}{
  \atomv_1 \ceq \atomv_2, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
   \cEnv \subst{\atomv_1}{\atomv_2}; \icEnv\subst{\atomv_1}{\atomv_2} \vDash \sconstr\subst{\atomv_1}{\atomv_2}
}{
  \atomv_1 \ceq \atomv_2, \cEnv ; \icEnv \vDash \sconstr
}
$$
\\
Just like in reduction on the goal, we deal with permutations through moving it to the right-hand side and then reducing it swap by swap through the left-hand side:
$$
\inferrule{
  \atomv \ceq \pi^{-1} \atomexp, \cEnv ; \icEnv \vDash \sconstr
}{
  \pi \atomv \ceq \atomexp, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
  \atomv \cneq \atomexp_1, \atomv \cneq \atomexp_2, \atomv     \ceq \atomexp, \cEnv ; \icEnv \vDash \sconstr \\
  \atomv \ceq  \atomexp_1, \atomv \cneq \atomexp_2, \atomexp_2 \ceq \atomexp, \cEnv ; \icEnv \vDash \sconstr \\
                           \atomv \ceq  \atomexp_2, \atomexp_1 \ceq \atomexp, \cEnv ; \icEnv \vDash \sconstr
}{
  \atomv \ceq \permswap{\atomexp_1}{\atomexp_1} \atomexp, \cEnv ; \icEnv \vDash \sconstr
}
$$
If the constructors of the term don't match, then we arrive at a contradiction
and consider the judgement solved:
$$
\inferrule{
}{
   \atomv \ceq \term_1 \term_2, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
}{
   \atomv \ceq \tbind{\atomexp} \term , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
}{
   \atomv \ceq \symb , \cEnv ; \icEnv \vDash \sconstr
}
$$
\\
To save some ink, from now on we will simply write that other constructors are trivial and not consider all the contradictory possibilities in writing.
Other rules mirror the ones we defined for the goal reduction:
$$
\inferrule{
   \atomexp_1 \cfresh \tbind{\atomexp_2} \term_2,\; \term_1 = \permswap{\atomexp_1}{\atomexp_2}\term_2 , \; \cEnv ; \icEnv \vDash \sconstr
}{
   \tbind{\atomexp_1} \term_1 \ceq \tbind{\atomexp_2} \term_2 , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
$$
\inferrule{
  \term_1 \ceq \term_2 , \; \term_1' \ceq \term_2', \;\cEnv ; \icEnv \vDash \sconstr
}{
   \term_1 \term_1' \ceq \term_2 \term_2' , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
$$
\inferrule{
  \symb_1 \cneq \symb_2
}{
  \symb_1 \ceq \symb_2 , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \sconstr
}{
  \symb\ceq \symb , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
\\
Atom inequality and freshness in variable simply contradict or extend the $\icEnv$ enviroment:
$$
\inferrule{
}{
  \atomv \cneq \atomv, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
  \cEnv ; \{\atomv_1 \cneq \atomv_2\} \cup \icEnv \vDash \sconstr
}{
  \atomv_1 \cneq \atomv_2, \; \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
  \cEnv ; \{\atomv \cfresh \termv\} \cup \icEnv \vDash \sconstr
}{
  \atomv \cfresh \termv, \; \cEnv ; \icEnv \vDash \sconstr
}
$$
\\
Otherwise it's a recursion on the right-hand side with the already established rules for dealing with permutations:
$$
\inferrule{
  \atomv \cneq \atomexp_1, \atomv \cneq \atomexp_2, \atomv     \cfresh \atomexp, \cEnv ; \icEnv \vDash \sconstr \\
  \atomv \ceq  \atomexp_1, \atomv \cneq \atomexp_2, \atomexp_2 \cfresh \atomexp, \cEnv ; \icEnv \vDash \sconstr \\
                           \atomv \ceq  \atomexp_2, \atomexp_1 \cfresh \atomexp, \cEnv ; \icEnv \vDash \sconstr
}{
  \atomv \cfresh \permswap{\atomexp_1}{\atomexp_1} \atomexp, \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \atomv \cneq \atomexp_1, \atomv \cneq \atomexp_2, \atomv     \cfresh \perm\termv, \cEnv ; \icEnv \vDash \sconstr \\
  \atomv \ceq  \atomexp_1, \atomv \cneq \atomexp_2, \atomexp_2 \cfresh \perm\termv, \cEnv ; \icEnv \vDash \sconstr \\
                           \atomv \ceq  \atomexp_2, \atomexp_1 \cfresh \perm\termv, \cEnv ; \icEnv \vDash \sconstr
}{
  \atomv \cfresh \permswap{\atomexp_1}{\atomexp_1} \perm\termv, \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \atomv \cfresh \atomexp, \; \cEnv ; \icEnv \vDash \sconstr \\
  \atomv \cfresh \atomexp, \; \atomv \cfresh \term,\;\cEnv ; \icEnv \vDash \sconstr
}{
  \atomv \cfresh \tbind{\atomexp} \term , \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \atomv \cfresh \term_1 , \cEnv ; \icEnv \vDash \sconstr \\
  \atomv \cfresh \term_2 , \cEnv ; \icEnv \vDash \sconstr
}{
  \atomv \cfresh \term_1 \term_2 , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
  \cEnv ; \icEnv \vDash \sconstr
}{
  \atomv \cfresh \symb, \cEnv ; \icEnv \vDash \sconstr
}
$$
\\
Variable being the same shape as other term is added to the $\icEnv$ environment:
$$
\inferrule{
  \cEnv ; \{\termv_1 \csheq \termv_2\} \cup \icEnv \vDash \sconstr
}{
  \termv_1 \csheq \termv_2, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
  \cEnv ; \{\termv \csheq \shape\} \cup \icEnv \vDash \sconstr
}{
  \termv \csheq \shape,\; \cEnv ; \icEnv \vDash \sconstr
}
$$
\\
Otherwise shape assumptions recurse on the shape structure:
$$
\inferrule{
  \cEnv ; \icEnv \vDash \sconstr
}{
  \atomv_1 \csheq \atomv_2, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
$$
\inferrule{
  \term_1 \csheq \term_2, \cEnv ; \icEnv \vDash \sconstr
}{
  \shbind\term_1 \csheq \shbind\term_2, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
$$
\inferrule{
  \term_1  \csheq \term_2 , \cEnv ; \icEnv \vDash \sconstr \\
  \term_1' \csheq \term_2', \cEnv ; \icEnv \vDash \sconstr
}{
  \term_1 \term_1' \csheq \term_2\term_2', \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
$$
\inferrule{
  \symb_1 \neq \symb_2
}{
  \symb_1 \csheq \symb_2 , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
}{
  \symb \csheq \symb , \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\text{Other term constructors trivial}
$$
Again, $\icEnv$ keeps track of terms that subshape given variable:
$$
\inferrule{
  \cEnv ; \{\term \cshlt \termv\} \cup \icEnv \vDash \sconstr
}{
  \term \cshlt \termv, \cEnv ; \icEnv \vDash \sconstr
}
$$
\\
Otherwise subshape assumptions recurse on the shape structure:
$$
\inferrule{
  \term_1 \csheq \term_2, \cEnv ; \icEnv \vDash \sconstr \\
  \term_1 \cshlt \term_2, \cEnv ; \icEnv \vDash \sconstr
}{
  \term_1 \cshlt \shbind \term_2, \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
  \term_1 \csheq \term_2, \cEnv ; \icEnv \vDash \sconstr \\
  \term_1 \csheq \term_2', \cEnv ; \icEnv \vDash \sconstr \\
  \term_1 \cshlt \term_2, \cEnv ; \icEnv \vDash \sconstr \\
  \term_1 \cshlt \term_2', \cEnv ; \icEnv \vDash \sconstr
}{
  \term_1 \cshlt \term_2 \term_2', \cEnv ; \icEnv \vDash \sconstr
}
$$
$$
\inferrule{
}{
  \term \cshlt \atomexp, \cEnv ; \icEnv \vDash \sconstr
}
\qquad
\inferrule{
}{
  \term \cshlt \symb, \cEnv ; \icEnv \vDash \sconstr
}
$$
In the next section we will explaining the semantics of environment extension $(\{\sconstr\} \cup \icEnv)$,
which can fail by arriving at contradictory environment $\lightning$, which
short-cuircuts the procedure:
$$
\inferrule{
}{
  \cEnv ; \lightning \vDash \sconstr
}
$$
\\
And that finishes the Solver's rules description.
Now the curious reader should feel obliged to ask themselves an important question:
does that procedure always stop?

To answer that question, we define the Solver's state by triple $(\cEnv, \icEnv, \sconstr)$ and introduce an ordering of the states by:
\begin{enumerate}[noitemsep]
  \item Number of distinct variables in $\cEnv$, $\icEnv$, and $\sconstr$.
  \item Depth of $\sconstr$.
  \item Number of assumptions of given depth in both $\cEnv$ and $\icEnv$.
  \item Number of assumptions of given depth in $\cEnv$.
\end{enumerate}

Then by analysing each rule we can see the reductions always arrive in a smaller
state.

\section{Implementation}
Environment $\icEnv$ is a quintuple
$({NeqAtoms}_{\icEnv}
, {Fresh}_{\icEnv}
, {VarShape}_{\icEnv}
, {Shape}_{\icEnv}
, {Subshape}_{\icEnv}
)$ where: \\
$NeqAtoms$ is a set of pairs of atoms that we know are different, \\
$Fresh$ is a mapping from atoms to variables that we know the atom is {Fresh} in,\\
$VarShape$ is a mapping from variables to shape-representative variables (i.e. all variables that are mapped in $VarShape$ to the same variable are of the same shape),\\
$Shape$ is a mapping from shape-representative variables to the shape that we know this variable must have,\\
$SubShape$ is a mapping from shape-representative variables to sets of shapes that we know this variable must supershape.
\\
\\
\newcommand{\shrep}[2][\icEnv]{\ensuremath{ #2_{#1}}}
\newcommand{\shenv}[2][\icEnv]{\ensuremath{ |#2|_{#1}}}
We can now define a way to compute the shape-representative variable:
$$
\shrep{\termv} :=
     \begin{cases}
      \termv          &\text{if } {VarShape}_{\icEnv}(\termv) = \emptyset \\
       \shrep{\termv'} &\text{if } {VarShape}_{\icEnv}(\termv) = \termv'
     \end{cases}
$$
And shape-reconstruction:
\begin{eqnarray*}
  \shenv{\termv}                 &:=&
  \begin{cases}
    \shenv{\termv'} &\text{if } {VarShape}_{\icEnv}(\termv) = \termv' \\
    \shape          &\text{if } {Shape}_{\icEnv}(\termv) = \shape \\
    \termv          &\text{otherwise}
  \end{cases} \\
  \shenv{\shatom}           &:=& \shatom \\
  \shenv{\shbind \shape}    &:=& \shbind \shenv{\shape} \\
  \shenv{\shape_1 \shape_2} &:=& \shenv{\shape_1} \shenv{\shape_2}\\
  \shenv{\symb}             &:=& \symb \\
  \shenv{\term}             &:=& \shenv{|\term|}
\end{eqnarray*}
\newcommand{\occurs}[2]{\ensuremath{ {#1}\text{ occurs in }{#2}}}
\newcommand{\stxoccurs}[2]{\ensuremath{ {#1}\text{ occurs syntactically in }{#2}}}
\newcommand{\pluseq}{\mathrel{+}=}
\newcommand{\minuseq}{\mathrel{-}=}
Now we can easily check for irreducible constraints in $\icEnv$:

\begin{eqnarray*}
  (\atomv_1 \cneq \atomv_2) \in \icEnv &:=& (\atomv_1 \cneq \atomv_2) \in {NeqAtoms}_{\icEnv} \\
  (\atomv \cfresh \termv) \in \icEnv &:=& \termv \in {Fresh}_{\icEnv}(\atomv) \\
  (\termv_1 \csheq \termv_2) \in \icEnv &:=& \shenv{\termv_1} \ceq \shenv{\termv_2} \\
  (\termv \csheq \shape) \in \icEnv &:=& \shape = {Shape}_{\icEnv}(\shrep{\termv})\\
  (\shape \cshlt \termv) \in \icEnv &:=& \shape \in {SubShape}_{\icEnv}(\shrep{\termv})
\end{eqnarray*}

Now we can define rules for the special occurs check:
$$
\inferrule{
  \stxoccurs{\shrep{\termv}}{\shenv{\shape}}
}{
  \icEnv \vDash \occurs{\termv}{\shape}
}
$$
$$
\inferrule{
  \stxoccurs{\shrep{\termv'}}{\shenv{\shape}} \\
  (\shape' \cshlt \termv') \in \icEnv  \\
  \icEnv \vDash \occurs{\termv}{\shape'}
}{
  \icEnv \vDash \occurs{\termv}{\shape}
}
$$
And finally, the rules for $\sconstr \cup \icEnv$.
Note that we are using the meta-field of $Assumptions$ to indicate that some of the
assumptions in $\icEnv$ are no longer "simple" and escape from $\icEnv$ back to
$\cEnv$ to be broken up by the \it{Solver}.

$$
 \{\atomv \cfresh \termv\} \cup \icEnv := \icEnv[{Fresh}(\atomv) \pluseq \termv]
$$
$$
\{\atomv \cneq \atomv'\} \cup \icEnv :=
  \begin{cases}
    \lightning &\text{if } \atomv \ceq \atomv'  \\
    \icEnv[{NeqAtoms} \pluseq (\atomv \cneq \atomv')] &\text{otherwise.}
  \end{cases}
$$

\begin{eqnarray*}
\{\termv \csheq \shape\} \cup \icEnv & := &
  \begin{cases}
    \lightning     &\text{if } \icEnv \vDash \occurs{\termv}{\shape} \\
    \icEnv' &\text{otherwise.}\\
  \end{cases} \\
  \text{where } \icEnv' & = & \icEnv .{Symbols} \{\shrep{\termv} \leadsto \shenv{\shape} \}\\
                        &   & \quad .{Subshapes}\{\shrep{\termv} \leadsto \shenv{\shape} \} \\
                        &   & \quad .{Shape}    \{\shrep{\termv} \leadsto \shenv{\shape} \}
\end{eqnarray*}

\begin{eqnarray*}
\{\termv \csheq \termv'\} \cup \icEnv & := &
  \begin{cases}
    \icEnv     &\text{if } \shrep{\termv} \ceq \shrep{\termv'} \\
    \icEnv &\text{if } \shenv{\termv} \ceq \shenv{\termv'} \\
    \lightning     &\text{if } \occurs{\shrep{\termv}}{\shenv{\termv'}} \\
    \lightning     &\text{if } \occurs{\shrep{\termv'}}{\shenv{\termv}} \\
    \icEnv' &\text{otherwise.}\\
  \end{cases} \\
  \text{where } \icEnv' & = & \icEnv .{Symbols}     \{\shrep{\termv} \leadsto \shrep{\termv'}\}\\
                        &   & \quad .{Subshapes}    \{\shrep{\termv} \leadsto \shrep{\termv'}\} \\
                        &   & \quad .{TransferShape}\{\shrep{\termv} \leadsto \shrep{\termv'}\} \\
                        &   & \quad [\: {Shape}    \minuseq (\shrep\termv) \\
                        &   & \quad ,   {SubShape} \minuseq (\shrep\termv) \\
                        &   & \quad ,   {VarShape} \pluseq  (\shrep\termv \mapsto \shrep\termv') \\
                        &   & \quad ]
\end{eqnarray*}
$$
\icEnv.{Symbols}\{\termv \leadsto \shape\} :=
  \begin{cases}
    \icEnv[{Symbols} \minuseq \termv, {Assumptions} \pluseq \text{symbol } \shape]    &\text{if } \shrep{\termv} \in \icEnv.{Symbols} \\
    \icEnv &\text{otherwise.}\\
  \end{cases} \\
$$
$$
\icEnv.{Shape}\{\termv \leadsto \shape\} :=
  \begin{cases}
    \icEnv[{Assumptions} \pluseq (\shape \csheq \shape')]    &\text{if } {Shape}_{\icEnv}(\shrep\termv) = \shape' \\
    \icEnv[{Shapes}      \pluseq (\termv \mapsto \shape)] &\text{otherwise.}\\
  \end{cases} \\
$$
$$
\icEnv.{SubShapes}\{\termv \leadsto \shape\} :=
  \icEnv[{Assumptions} \pluseq {Subshapes}_{\icEnv}(\termv) \cshlt \shape]
$$
$$
\icEnv.{TransferShape}\{\termv \leadsto \termv'\} :=
  \begin{cases}
    \icEnv.{Shape}\{termv' \leadsto  \shape'\}    &\text{if } {Shape}_{\icEnv}(\shrep\termv) = \shape \\
    \icEnv &\text{otherwise.}\\
  \end{cases} \\
$$
$$
\icEnv\{\termv \mapsto \term\} := \{\termv \csheq \shenv{\term} \} \cup \icEnv.{Fresh}\{\termv \mapsto \term\}
$$
$$
\icEnv.{Fresh}\{\termv \mapsto \term\} :=
 \icEnv[{Fresh}.map(\text{fun } (\atomv \cfresh \mathbb{\termv}) \mapsto \atomv \cfresh (\mathbb{\termv} \setminus \{ \termv\})] \;
 \cup \bigcup_{\substack{(\atomv \cfresh \mathbb{\termv}) \in {Fresh}_{\icEnv} \\ \termv \in \mathbb{\termv}}}
    \{ \atomv \cfresh \term \}
$$
$$
\icEnv\{\atomv \mapsto \atomv'\} := \icEnv.{Fresh}\{\atomv \mapsto \atomv'\}.{NeqAtoms}\{\atomv \mapsto \atomv'\}]
$$
$$
\icEnv.{Fresh}\{\atomv \mapsto \atomv'\} := \icEnv[{Fresh} \minuseq \atomv][{Fresh} \pluseq \{\atomv' \cfresh \icEnv.{Fresh}(\atomv)\}]
$$
$$
\icEnv.{NeqAtoms}\{\atomv \mapsto \atomv'\} :=
\icEnv[{NeqAtoms} = \emptyset] \;
 \cup \bigcup_{ (\atomv_1 \cneq \atomv_2) \in {NeqAtoms}_{\icEnv}  }
    \{ \atomv_1\{\atomv \mapsto \atomv'\} \cneq \atomv_2\{\atomv \mapsto \atomv'\}\}
$$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Higher Order Logic}

On top of the sublogic of constraints, we build a higher-order logic.
Due to the involvement of atoms, terms, binders, and constraints,
we introduce kinds to ensure that the formulas we deal with \it{make sense}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Kinds}

\begin{tabular}{rclr}
$\kind$ & $::=$ & $\kProp
            \bnfor \kind \karrow \kind
            \bnfor \kForallAtom{\atomv} \kind
            \bnfor \kForallTerm{\termv} \kind
            \bnfor \kGuard{\constr} \kind$
    & (kinds)
\end{tabular}

\begin{tabular}{rclr}
$\formphi \ofkind$ & $\kProp$ & ---  $\formphi$ is a propositional formula. \\
$\formphi \ofkind$ & $\kind_1 \karrow \kind_2$ & ---  $\formphi$ is function that takes a formula of kind $\kind_1$, \\
  & &  and produces a formula of kind $\kind_2$. \\
$\formphi \ofkind$ & $\kForallAtom{\atomv} \kind$ & ---  $\formphi$ is function that takes an an atom expression, \\
  & &  binds it to $\atomv$ and produces a formula of kind $\kind$.\\
$\formphi \ofkind$ & $\kForallTerm{\termv} \kind$ & ---  $\formphi$ is function that takes a term, \\
  & &  binds it to $\termv$ and produces a formula of kind $\kind$.\\
$\formphi \ofkind$ & $\kGuard{\constr} \kind$ & ---  $\formphi$ is a formula of kind $\kind$ as long as $\constr$ is satisfied.
\end{tabular}
\\ \\
Notice that as constraints occur in kinds, we cannot simply give functions
from atoms some kind ${Atom}\karrow\kind$, but we must know \it{which} atom
is bound there, to substitute for it in $\kind$ the same way we substitute
that atom for an atom expression in the function body when applying it to the formula.
The \it{guarded kind} $\kGuard{\constr} \kind$ is most importantly used in
kinding of the fixpoint formulas, which we will explain in later sections.

\section{Subkinding}
Kinding relation is relaxed through the \it{subkinding},
a relation that is naturally reflexive and transitive:
$$
\inference{
}{
  \cEnv \vdash \kind \subkind \kind
}
\qquad
\inference{
  \cEnv \vdash \kind_1 \subkind \kind_2 &
  \cEnv \vdash \kind_2 \subkind \kind_3
}{
  \cEnv \vdash \kind_1 \subkind \kind_3
}
$$
Universally quantified kinds only subkind if they are quantified over the same name:
$$
\inference{
  \cEnv \vdash \kind_1 \subkind \kind_2
}{
  \cEnv \vdash \kForallAtom{\atomv} \kind_1 \subkind \kForallAtom{\atomv} \kind_2
}
\qquad
\inference{
  \cEnv \vdash \kind_1 \subkind \kind_2
}{
  \cEnv \vdash \kForallTerm{\termv} \kind_1 \subkind \kForallTerm{\termv} \kind_2
}
$$
Function kind is contravariant to the subkinding relation on the left argument:
$$
\inference{
  \cEnv \vdash \kind_1' \subkind \kind_1 &
  \cEnv \vdash \kind_2 \subkind \kind_2'
}{
  \cEnv \vdash \kind_1 \karrow \kind_2 \subkind \kind_1' \karrow \kind_2'
}
$$
Constraints that are solved through $\vDash$ relation can be dropped:
$$
\inference{
  \cEnv \vDash \constr
}{
  \cEnv \vdash \kGuard{\constr}\kind \subkind \kind
}
$$
And constraints can be moved to the enviroment from the right-hand side:
$$
\inference{
  \cEnv, \constr \vdash \kind_1 \subkind \kind_2
}{
  \cEnv \vdash \kind_1 \subkind \kGuard{\constr}\kind_2
}
$$
Note that there is no structural subkinding rule for guarded kinds like
$$
\inference{\cEnv \vdash \kind_1 \subkind \kind_2}{
  \cEnv \vdash \kGuard{\constr} \kind_1 \subkind \kGuard{\constr} \kind_2
}[\ensuremath{\times}]
$$
Such a rule can be derived from both subkinding rules for guarded kind,
transitivity, and weakening.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Formulas}
Formulas include standard connectives (of kind $\kProp$):

\begin{tabular}{rrlr}
$\formphi$ & $::=$ & $\bot
               \bnfor \top
               \bnfor \formphi \vee \formphi
               \bnfor \formphi \wedge \formphi
               \bnfor \formphi \fImp \formphi
               \bnfor \ldots $ & (formulas)
\end{tabular}
\\ \\
Quantification over atoms and terms (on formulas of kind $\kProp$):

\begin{tabular}{rrlr}
$\formphi$ & $::=$ & $\ldots
               \bnfor \fForallAtom{\atomv} \formphi
               \bnfor \fForallTerm{\termv} \formphi
               \bnfor \fExistsAtom{\atomv} \formphi
               \bnfor \fExistsTerm{\termv} \formphi
               \bnfor \ldots$
    & (formulas)
\end{tabular}
\\ \\
Constraints, guards, and propositional variables:

\begin{tabular}{rrlr}
$\formphi$ & $::=$ & $\ldots
               \bnfor \fConstr{\constr}
               \bnfor \fCAnd{\constr} \formphi
               \bnfor \fCImp{\constr} \formphi
               \bnfor \propv
               \bnfor \ldots$  (formulas)
\end{tabular}
$$
\inference{
}{
  \cEnv; \kEnv \vdash \fConstr{\constr} \ofkind \kProp
}
\qquad
\inference{
  \cEnv,\constr; \kEnv \vdash \formphi \ofkind \kProp
}{
  \cEnv; \kEnv \vdash \fCAnd{\constr} \formphi \ofkind \kProp
}
\qquad
\inference{
  \cEnv,\constr; \kEnv \vdash \formphi \ofkind \kProp
}{
  \cEnv; \kEnv \vdash \fCImp{\constr} \formphi \ofkind \kProp
}
\qquad
\inference{
  (\propv \ofkind \kind) \in \kEnv
}{
  \cEnv; \kEnv \vdash  \propv \ofkind \kind
}
$$
Propositional variables, functions and applications:

\begin{tabular}{rrlr}
$\formphi$ & $::=$ & $\ldots
               \bnfor \fLamAtom{\atomv} \formphi
               \bnfor \fLamTerm{\termv} \formphi
               \bnfor \fLamForm{\propv}{\kind} \formphi
               \bnfor \formphi \fAppAtom{\atomexp}
               \bnfor \formphi \fAppTerm{\term}
               \bnfor \formphi \fApp \formphi
               \bnfor \ldots$
    & (formulas)
\end{tabular}\\
\begin{align*}
\inference{
  \cEnv; \kEnv \vdash \formphi \ofkind \kind
}{
  \cEnv; \kEnv \vdash \fLamAtom{\atomv} \formphi \ofkind \kForallAtom{\atomv}\kind
}
& \qquad
\inference{
  \cEnv;\kEnv\vdash \formphi \ofkind \kForallAtom{\atomv}\kind
}{
  \cEnv;\kEnv\vdash \formphi \fAppAtom{\atomexp} \ofkind \kind \subst{\atomv}{\atomexp}
}
\\ & \\
\inference{
  \cEnv; \kEnv \vdash \formphi \ofkind \kind
}{
  \cEnv; \kEnv \vdash \fLamTerm{\termv} \formphi \ofkind \kForallTerm{\termv}\kind
}
& \qquad
\inference{
  \cEnv;\kEnv\vdash \formphi \ofkind \kForallTerm{\termv}\kind
}{
  \cEnv;\kEnv\vdash \formphi \fAppTerm{\term} \ofkind \kind\subst{\termv}{\term}
}
\\ & \\
\inference{
  \cEnv; \kEnv, \propv \ofkind \kind_1 \vdash \formphi \ofkind \kind_2
}{
  \cEnv; \kEnv \vdash \fLamForm{\propv}{\kind_1} \formphi \ofkind \kind_1 \karrow \kind_2
}
& \qquad
\inference{
  \cEnv; \kEnv \vdash \formphi_1 \ofkind \kind' \karrow \kind &
  \cEnv; \kEnv \vdash \formphi_2 \ofkind \kind'
}{
  \cEnv;\kEnv\vdash \formphi_1 \fApp \formphi_2 \ofkind \kind
}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Fixpoint}
\newcommand{\fix}[3]{\ensuremath{\text{fix }#1(#2)\ofkind#3=}}
And finish the definition of formulas with \it{fixpoint} function:

\begin{tabular}{rrlr}
$\formphi$ & $::=$ & $\ldots
               \bnfor \fix{\propv}{\termv}{\kind}{\formphi} $
    & (formulas)
\end{tabular}
$$
\inference{
  \cEnv;\kEnv, (\propv \ofkind \kForallTerm{Y} \kGuard{Y \cshlt \termv}{\kind\subst{\termv}{Y}})\vdash \formphi \ofkind \kind
}{
  \cEnv;\kEnv\vdash (\fix{\propv}{\termv}{\kind}{\formphi}) \ofkind \kForallTerm{\termv}{\kind}
}
$$
The fixpoint constructor allows us to express \it{recursive} predicates over terms,
but only such that the recursive applications are on structurally smaller terms,
which we express in the kinding rule through the kinding $(\propv \ofkind \kForallTerm{Y} \kGuard{Y \cshlt \termv}{\kind\subst{\termv}{Y}})$.
To evaluate a fixpoint function applied to a term, simply substitute the bound
variable with the given term and replace recursive calls inside the fixpoint's body with the fixpoint itself.

$$
(\fix{\propv}{\termv}{\kind}{\formphi})\fApp\term
\equiv
\formphi\subst{\termv}{\term}\subst{\propv}{(\fix{\propv}{\termv}{\kind}{\formphi})}
$$
Because the applied term is finite
and we always recurse on structurally smaller terms,
the final formula after all substitutions must also be finite
--— thanks to the semantics of constraints and kinds.

To familiarize the reader with the fixpoint formulas,
we present how Peano arithmetic can be modeled in our logic.
Given symbols $0$ and $S$ for natural number construction,
one can write a predicate that a term models some natural number:
$$
\fix{Nat}{N}{\kProp}{(N \ceq 0) \vee (\fExistsTerm{M} \fCAnd{N \ceq {S \tapp M}} ({Nat}\fAppTerm{M}))}
$$
Notice how the constraint $(N \ceq {S \tapp M})$ guards the recursive call to $Nat$,
ensuring that constraint $(M \cshlt N)$ will be satisfied during kind checking of
$({{Nat}\fAppTerm{M}})$ in the kind derivation of the whole formula
$({Nat} \ofkind \kForallTerm{N}{\kProp})$.

Similarly, we can define addition: \\ \\
$\fix{PlusEq}{N}{\kForallTerm{M}\kForallTerm{K}\kProp}{\fLamTerm{M}\fLamTerm{K}}$ \\
$\text{ }\qquad
  (\fCAnd{N \ceq 0}{(M \ceq K)}) \;\vee\;
   (\fExistsTerm{N', K'}\fCAnd{N \ceq {S \tapp N'}}\fCAnd{K \ceq {S \tapp K'}}{({PlusEq}\fApp{N'}\fApp{M}\fApp{K'})}
   )
$
\\
TODO: Write how $N$ is treated differently from $M$ and $K$?
\\
See more interesting examples of fixpoints usage in the chapter on STLC.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Proof theory}

\newcommand{\rel}[2][\Gamma;C]{\ensuremath{#1\vdash#2}}
\newcommand{\types}[3][\Gamma]{\rel[#1]{#2 : #3}}
\newcommand{\interp}[2][\tmEnv]{\left\llbracket {#2} \right\rrbracket_{#1}}
\newcommand{\arr}{\rightarrow }
% \newcommand{\inference}[2]{\inferrule{ #1}{#2}}
\newcommand{\all}[1][x]{\ensuremath{\forall #1.\:}}
\newcommand{\exi}[1][x]{\ensuremath{\exists #1.\:}}
\newcommand{\karr}{\Rightarrow }
\newcommand{\lam}[1][x]{\lambda{#1}.\;}
\newcommand{\jgmnt[2]}[\cEnv;\Theta]{\ensuremath{#1 \vdash #2}}
\newcommand{\cjgmnt[2]}[\cEnv]{\ensuremath{#1 \vDash #2}}
\newcommand{\fv[1]}[\cEnv;\Theta]{\ensuremath{\operatorname{FV}(#1)}}

Finally, we can define proof-theoretic rules.
Starting with inference rules for assumption,
we can already define its constraint-sublogic analogues that employ the solver.
And while the $\vdash$ relation we define is purely syntactic,
we can still use semantic $\vDash$ because of its decidability.
$$
  \inference{
    \formphi \in \Theta
  }{
    \jgmnt[\cEnv;\Theta]{\formphi}
  }[(\ensuremath{Assumption})]
  \qquad
  \inference{
    \cjgmnt[\cEnv]{\constr}
  }{
    \jgmnt[\cEnv;\Theta]{\constr}
  }[(\ensuremath{constr^i})]
$$
Again, for \it{ex falso}, we define an analogous proof constructor for dealing with a contradictory
constraint environment.
Note that there are many constraints that can be used as $\bot_\constr$, i.e.
constraints that are always false, and the solver will only \it{prove} them
if we supply it with contradictory assumptions.
$$
  \inference{
    \jgmnt[\cEnv;\Theta]{\bot}
  }{
    \jgmnt[\cEnv;\Theta]{\formphi}
  }[(\ensuremath{\bot^e})]
  \qquad
  \inference{
    \cjgmnt[\cEnv]{\bot_\constr}
    }{
    \jgmnt[\cEnv;\Theta]{\formphi}
  }[(\ensuremath{constr^e})]
$$
Inference rules for implication are standard, and the reason we present them here
is not to bore the reader, but to point out the similarities to their constraint analogues.
$$
  \inference{
    \jgmnt[\cEnv;\Theta,\formphi_1]{\formphi_2}
  }{
    \jgmnt[\cEnv;\Theta]{\formphi_1 \fImp \formphi_2}
  }[(\ensuremath{\fImp^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv_1;\Theta_1]{\formphi_1} &
    \jgmnt[\cEnv_2;\Theta_2]{\formphi_1 \fImp \formphi_2}
    }{
    \jgmnt[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]{\formphi_2}
  }[(\ensuremath{\fImp^e})]
$$
$$
  \inference{
    \jgmnt[\cEnv, \constr;\Theta]{\formphi}
  }{
    \jgmnt[\cEnv;\Theta]{\fCImp{\constr}\formphi}
  }[(\ensuremath{\fCImp{\cdot}^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv_1;\Theta_1]{\constr} &
    \jgmnt[\cEnv_2;\Theta_2]{\fCImp{\constr}\formphi}
    }{
    \jgmnt[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]{\formphi}
  }[(\ensuremath{\fCImp{\cdot}^e})]
$$
Notice that in the case of constraint-and-guard, the rule for elimination is restricted
to only formulas of kind $\kProp$.
This is due to the nature of the guard --- if we want to eliminate it,
we can only do so with formulas that \it{make sense} on their own,
without that $\constr$ guard.
$$
  \inference{
    \jgmnt[\cEnv_1;\Theta_1]{\formphi_1} &
    \jgmnt[\cEnv_2;\Theta_2]{\formphi_2}
  }{
    \jgmnt[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]{\formphi_1 \wedge \formphi_2}
  }[(\ensuremath{\wedge^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi_1 \wedge \formphi_2}
    }{
    \jgmnt[\cEnv;\Theta]{\formphi_1}
  }[(\ensuremath{\wedge^e_1})]\qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi_1 \wedge \formphi_2}
    }{
    \jgmnt[\cEnv;\Theta]{\formphi_2}
  }[(\ensuremath{\wedge^e_2})]
$$
$$
  \inference{
    \cjgmnt[\cEnv]{\constr} &
    \jgmnt[\cEnv, \constr;\Theta]{\formphi}
  }{
    \jgmnt[\cEnv;\Theta]{\fCAnd{\constr}\formphi}
  }[(\ensuremath{\fCAnd{\cdot}^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\fCAnd{\constr}\formphi}
    }{
    \jgmnt[\cEnv;\Theta]{\constr}
  }[(\ensuremath{\fCAnd{\cdot}^e_1})]\qquad
  \inference{
    \jgmnt[\cEnv]{\fCAnd{\constr}\formphi} &
    \jgmnt[\cEnv;\Theta]{\formphi: \kProp}
    }{
    \jgmnt[\cEnv;\Theta]{\formphi}
  }[(\ensuremath{\fCAnd{\cdot}^e_2})]
$$
Inference rules for disjunction and quantifiers are rather straightforward.
As one would expect, we restrict the generalized name to be \it{fresh} in the environment (it may not occur in any of the assumptions),
and the names given to witnesses of existential quantification must also be \it{fresh}.
Rules for quantifiers always come in pairs --- one for the atoms and one for the variables.
$$
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi_1}
    }{
    \jgmnt[\cEnv;\Theta]{\formphi_1 \vee \formphi_2}
  }[(\ensuremath{\vee^i_1})]
  \qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi_2}
  }{
    \jgmnt[\cEnv;\Theta]{\formphi_1 \vee \formphi_2}
  }[(\ensuremath{\vee^i_2})]
  \qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi_1 \vee \formphi_2} \\
    \jgmnt[\cEnv;\Theta,\formphi_1]{\psi} &
    \jgmnt[\cEnv;\Theta,\formphi_2]{\psi}
  }{
    \jgmnt[\cEnv;\Theta]{\psi}
  }[(\ensuremath{\vee^e})]
$$
$$
  \inference{
    \atomv \notin \fv[\cEnv;\Theta] &
    \jgmnt[\cEnv;\Theta]{\formphi}
  }{
    \jgmnt[\cEnv;\Theta]{\fForallAtom{\atomv}\formphi}
  }[(\ensuremath{{\fForallAtom{}}^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\fForallAtom{\atomv}\formphi}
  }{
    \jgmnt[\cEnv;\Theta]{\formphi \{\atomv \mapsto \atomv'\}}
  }[(\ensuremath{{\fForallAtom{}}^e})]
$$
$$
  \inference{
    \termv \notin \fv[\cEnv;\Theta] &
    \jgmnt[\cEnv;\Theta]{\formphi}
  }{
    \jgmnt[\cEnv;\Theta]{\fForallTerm{\termv}\formphi}
  }[(\ensuremath{{\fForallTerm{}}^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv;\Theta]{\fForallTerm{\termv}\formphi}
  }{
    \jgmnt[\cEnv;\Theta]{\formphi \{\termv \mapsto \termv'\}}
  }[(\ensuremath{{\fForallTerm{}}^e})]
$$
$$
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi \{\atomv \mapsto \atomv'\}}
    }{
    \jgmnt[\cEnv;\Theta]{\fExistsAtom{\atomv}\formphi}
  }[(\ensuremath{{\fExistsAtom{}}^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv_1;\Theta_1]{\fExistsAtom{\atomv}\formphi} \\
    \jgmnt[\cEnv_2;\Theta_2,\formphi \{\atomv \mapsto \atomv'\}]{\psi} \\
    \atomv' \notin \fv[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]
    }{
    \jgmnt[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]{\psi}
  }[(\ensuremath{{\fExistsAtom{}}^e})]
$$
$$
  \inference{
    \jgmnt[\cEnv;\Theta]{\formphi \{\termv \mapsto \termv'\}}
    }{
    \jgmnt[\cEnv;\Theta]{\fExistsTerm{\termv}\formphi}
  }[(\ensuremath{{\fExistsTerm{}}^i})]
  \qquad
  \inference{
    \jgmnt[\cEnv_1;\Theta_1]{\fExistsTerm{\termv}\formphi} \\
    \jgmnt[\cEnv_2;\Theta_2,\formphi \{\termv \mapsto \termv'\}]{\psi} \\
    \termv' \notin \fv[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]
    }{
    \jgmnt[\cEnv_1 \cup \cEnv_2;\Theta_2 \cup \Theta_2]{\psi}
  }[(\ensuremath{{\fExistsTerm{}}^e})]
$$
To make the framework more flexible we introduce a way for using equivalent formulas:
$$
  \inference{
    \jgmnt[\cEnv;\Theta]{\psi} &
    \jgmnt[\cEnv;\Theta]{\psi \equiv \formphi}
    }{
    \jgmnt[\cEnv;\Theta]{\formphi}
  }[(\ensuremath{Equiv})]
$$
And a way to substitute atoms for atomic expression and variables for terms, if the solver can prove their equality:
$$
  \inference{
    \cjgmnt[\cEnv]{\atomv \ceq \atomexp} &
    \jgmnt[\cEnv;\Theta]{\formphi}
    }{
    \jgmnt[\cEnv\{\atomv \mapsto \atomexp\};\Theta\{\atomv \mapsto \atomexp\}]{\formphi\{\atomv \mapsto \atomexp\}}
  }[(\ensuremath{\mapsto_A})]
\qquad
  \inference{
    \cjgmnt[\cEnv]{\termv \ceq \term} &
    \jgmnt[\cEnv;\Theta]{\formphi}
    }{
    \jgmnt[\cEnv\{\termv \mapsto \term\};\Theta\{\termv \mapsto \term\}]{\formphi\{\termv \mapsto \term\}}
  }[(\ensuremath{\mapsto_T})]
$$
Finally, we define induction over term structure,
and thanks to the constraints sublogic we can easily define the notion of
\it{smaller terms} needed for the inductive hypothesis:
$$
  \inference{
    \jgmnt[\cEnv;\Theta, (\fForallTerm{\termv'} \fCImp{\termv' \cshlt \termv} \formphi(\termv'))]{\formphi(\termv)}
    }{
    \jgmnt[\cEnv;\Theta]{\fForallTerm{\termv} \formphi(\termv)}
  }[(\ensuremath{Induction})]
$$
\\
We also define some axioms about constraint sublogic:
\begin{enumerate}
\item Atoms can be compared in a deterministic fashion,
$$
  \inference{
    }{
    \jgmnt[]{\fForallAtom{\:\atomv,\:\atomv'} (\atomv \ceq \atomv') \vee (\atomv \cneq \atomv')}
  }[(\ensuremath{Axiom_{Compare}})]
$$
\item There always exists a \it{fresh} atom,
$$
  \inference{
    }{
    \jgmnt[]{\fForallTerm{\termv} \:\fExistsAtom{\atomv} (\atomv \cfresh \termv)}
  }[(\ensuremath{Axiom_{Fresh}})]
$$
\item We can always deduce the structure of a term.
\begin{eqnarray*}
  & \inference{
    }{
    \jgmnt[]{\fForallTerm{\termv} (\fExistsAtom{\atomv}\: \termv = \atomv) \vee (\fExistsAtom{\atomv}\:\fExistsTerm{\termv'}\: \termv = \tbind{\atomv}{\termv'}) }
  }[(\ensuremath{Axiom_{Inversion}})] \\
  & \ensuremath{\vee (\fExistsTerm{\termv_1,\:\termv_2}\: \termv = \tbind{\atomv}{\termv'}) \vee ({symbol}\: \termv) } \\
\end{eqnarray*}
\end{enumerate}

The equivalence relation ($\formphi_1 \equiv \formphi_2$) is a bit complicated
due to subkinding, existence of formulas
with fixpoints, functions, applications,
and presence of an environment with variable mapping.
Nonetheless, it's simply that - \it{an equivalence relation} - and it
behaves as expected. We will only highlight the interesting parts.

Equivalence checking procedure starts by computing weak head normal form (up to some \it{depth} denoted by $n$):
\begin{align*}
\tt{compute }\Sigma\tt{ }n\tt{ }P
& \quad\leadsto\quad
\tt{compute }\Sigma\tt{ }n\tt{ }\formphi
\\
&\;\text{when} \quad \Sigma(P) = \formphi
\\ & \\
\tt{compute }\Sigma\tt{ }n\tt{ }{(\formphi \fAppAtom \atomexp )}
& \quad\leadsto\quad
\tt{compute }\Sigma\tt{ }(n' - 1)\tt{ }{\formphi'\subst{\atomv}{\atomexp}} \\
&\;\text{when} \quad \tt{compute }\Sigma\tt{ }n\tt{ }{\formphi} \;\leadsto^{*}\; (n',\fLamAtom{\atomv}\formphi')
\\ & \\
\tt{compute }\Sigma\tt{ }n\tt{ }{(\formphi \fAppTerm \term )}
& \quad\leadsto\quad
\tt{compute }\Sigma\tt{ }(n' - 1)\tt{ }{\formphi'\subst{\termv}{\term}} \\
&\;\text{when} \quad \tt{compute }\Sigma\tt{ }n\tt{ }{\formphi} \;\leadsto^{*}\; (n',\fLamTerm{\termv}\formphi')
\\ & \\
\tt{compute }\Sigma\tt{ }n\tt{ }{(\formphi \fAppTerm \term )}
& \quad\leadsto\quad
\tt{compute }\Sigma\subst{P}{\phi'}\tt{ }(n' - 1)\tt{ }{\formphi'\subst{\termv}{\term}}\\
&\;\text{when} \quad \tt{compute }\Sigma\tt{ }n\tt{ }{\formphi} \;\leadsto^{*}\; (n',\fix{P}{\termv}{\kind}\formphi')
\\ & \\
\tt{compute }\Sigma\tt{ }n\tt{ }{(\formphi_1 \fApp \formphi_2 )}
& \quad\leadsto\quad
\tt{compute }\Sigma\tt{ }(n_2 - 1)\tt{ }{\psi_1\subst{\propv}{\psi_2}}\\
&\;\text{when} \quad \tt{compute }\Sigma\tt{ }n\tt{ }{\formphi_1} \;\leadsto^{*}\; (n_1, \fLamForm{\propv}{\kind}{\psi_1})\\
&\;\text{ and } \quad \tt{compute }\Sigma\tt{ }n_1\tt{ }{\formphi_2} \;\leadsto^{*}\; (n_2, \psi_2)
\end{align*}
After we've reached WHNF computation \it{depth} ($ n \leqslant 0$) or cannot reduce the formula further,
we can progress naively:
\\
$$
  \inference{
    \jgmnt[\Gamma; \Sigma]{\formphi_1 \equiv \formphi_2 } &
    \jgmnt[\Gamma; \Sigma]{\psi_1 \equiv \psi_2 }
    }{
    \jgmnt[\Gamma; \Sigma]{\formphi_1 \fImp \psi_1 \equiv \formphi_2 \fImp \psi_2 }
  }
  \quad
  \inference{
    \jgmnt[\Gamma; \Sigma]{\formphi_1 \equiv \formphi_2 } &
    \jgmnt[\Gamma; \Sigma]{\psi_1 \equiv \psi_2 }
    }{
    \jgmnt[\Gamma; \Sigma]{\formphi_1 \wedge \psi_1 \equiv \formphi_2 \wedge \psi_2 }
  }
  \quad
  \cdots
$$
\\
$$
  \inference{
    \cjgmnt[\Gamma]{\term_1 \ceq \term_2} &
    \jgmnt[\Gamma; \Sigma]{\formphi_1 \equiv \formphi_2 }
    }{
    \jgmnt[\Gamma; \Sigma]{\formphi_1 \fAppTerm \term_1 \equiv \formphi_2 \fAppTerm \term_2 }
  }
$$
\\
Note that we allow \it{different terms} in equivalent formulas as long as
constraints-enviroment $\cEnv$ ensures their equality is provable.
For functions, we simply substitute the arguments of both left and right side
to the same, fresh name.
\\
$$
  \inference{
    \termv \notin \fv[\Gamma; \Sigma] \\
    \jgmnt[\Gamma; \Sigma]{\formphi_1[\termv_1 \mapsto \termv] \equiv \formphi_2[\termv_2 \mapsto \termv] }
    }{
    \jgmnt[\Gamma; \Sigma]{\fLamTerm{\termv_1}\formphi_1 \equiv \fLamTerm{\termv_2}\formphi_2 }
  }
$$

$$
  \inference{
    \kind_1 \subkind \kind_2 \\
    \jgmnt[\Gamma; \Sigma]{\formphi_1[P_1 \mapsto P] \equiv \formphi_2[P_2 \mapsto P] }
    }{
    \jgmnt[\Gamma; \Sigma]{\fLamForm{P_1}{\kind_1}{\formphi_1} \equiv \fLamForm{P_2}{\kind_2}{\formphi_2}}
  }
$$

$$
  \inference{
    \kind_1 \subkind \kind_2 &
    P \notin \fv[\Gamma; \Sigma] & \termv \notin \fv[\Gamma; \Sigma] \\
    \jgmnt[\Gamma; \Sigma]{\formphi_1[P_1 \mapsto P, \termv_1 \mapsto \termv] \equiv \formphi_2[P_2 \mapsto P, \termv_2 \mapsto \termv] }
    }{
    \jgmnt[\Gamma; \Sigma]{\fix{P_1}{\termv_1}{\kind_1}\formphi_1 \equiv \fix{P_2}{\termv_2}{\kind_2}\formphi_2}
  }
$$
Quantifiers are handled the same way as function above --- as they all are a form of bind.
To handle formulas with constraints we introduce \it{constraint equivalence} relation,
which does nothing more than use the Solver to check that the constructors
of constraint are the same and that arguments are equal to each other in the Solver's sense,
analogusly as with terms above.
\\
$$
  \inference{
    \jgmnt[\Gamma]{\constr_1 \equiv \constr_2 } &
    \jgmnt[\Gamma; \Sigma]{\formphi_1 \equiv \formphi_2 }
  }{
    \jgmnt[\Gamma; \Sigma]{\fCAnd{\constr_1}\formphi_1 \equiv \fCAnd{\constr_2}\formphi_2 }
  }
\qquad
  \inference{
    \cjgmnt[\Gamma]{\atomv_1 \ceq \atomv_2 } & \cjgmnt[\Gamma]{\term_1 \ceq \term_2 }
  }{
    \jgmnt[\Gamma]{(\atomv_1 \cfresh \term_1) \equiv (\atomv_2 \cfresh \term_2) }
  }
\qquad
\cdots
$$
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{Model}

% Definition of a model of our logic is bit involved,
% due to presence of subkinding relation.
% We will proceed in two steps.
% First, for each kind $\kind$ we define its \emph{domain} $\kindDom{\kind}$.
% Then we will interpret each kind as a predicate on elements of its domain.
% We fix some Heyting algebra $\PropAlg$
% in which we will interpret propositions.
% Then kind domains are defined in the following way.
% \begin{eqnarray*}
% \kindDom{\kProp}                     & = & \PropAlg \\
% \kindDom{\kind_1 \karrow \kind_2}    & = & \kindDom{\kind_1} \rightarrow \kindDom{\kind_2} \\
% \kindDom{\kForallAtom{\atomv}\kind}  & = & \atomDom          \rightarrow \kindDom{\kind} \\
% \kindDom{\kForallTerm{\termv}\kind}  & = & \termDom          \rightarrow \kindDom{\kind} \\
% \kindDom{\kGuard{\constr}\kind}      & = & \kindDom{\kind}
% \end{eqnarray*}

% %%%%%%%%%%%%%%%%%%%%%%%
% And kind interpretation like this:
% \begin{eqnarray*}
% \termMdl{\kProp}{\tmEnv}                      & = & \{ \bot, \top \} \\
% \termMdl{\kind_1 \karrow \kind_2}{\tmEnv}     & = & \{f \mid \forall P \in \termMdl{\kind_1}{\tmEnv}.\: f(P) \in \termMdl{\kind_2}{\tmEnv} \} \\
% \termMdl{\kForallAtom{\atomv}\kind}{\tmEnv}   & = & \{f \mid \forall A \in \atomDom.\: f(A) \in \termMdl{\kind}{\tmEnv[\atomv \mapsto A]}\} \\
% \termMdl{\kForallTerm{\termv}\kind}{\tmEnv}   & = & \{f \mid \forall T \in \termDom.\: f(T) \in \termMdl{\kind}{\tmEnv[\termv \mapsto T]}\} \\
% \termMdl{\kGuard{\constr}\kind}{\tmEnv}       & = & \{x \mid \tmEnv \vDash \constr \implies x \in \termMdl{\kind}{\tmEnv} \}
% \end{eqnarray*}



% And finally the kind derivation model:
% \begin{eqnarray*}
% \interp{\inferrule{ }{\types{\top}{\kProp}}} & = & \top \\
% \interp{\inference{ }{\types{ \propv}{\Gamma( \propv)}}} & = & \tmEnv(\propv) \\
%     \interp{\inference{}{\types{\constr}{\kProp}}} & = & \texttt{if } \tmEnv \vDash \constr \texttt{ then } \top \texttt{ else } \bot
% \end{eqnarray*}

% \begin{eqnarray*}
%     \interp{
%         \inference{D_1 : \types{\formphi_1 }{\kProp} \\ D_2 : \types{\formphi_2 }{\kProp}
%     }{
%         \types{\formphi_1 \wedge \formphi_2}{\kProp}}
%     } & = & \interp{D_1} \wedge_\PropAlg \interp{D_2} \\
%     \interp{
%         \inference{D_1 : \types{\formphi_1 }{\kProp}  \\ D_2 : \types{\formphi_2 }{\kProp}
%     }{
%         \types{\formphi_1 \vee \formphi_2}{\kProp}}
%     } & = & \interp{D_1} \vee_\PropAlg \interp{D_2} \\
%     \interp{
%         \inference{D_1 : \types{\formphi_1 }{\kProp}  \\ D_2 : \types{\formphi_2 }{\kProp}
%     }{
%         \types{\formphi_1 \Rightarrow \formphi_2}{\kProp}}
%     } & = & \interp{D_1} \Rightarrow_\PropAlg \interp{D_2}
% \end{eqnarray*}

% \begin{eqnarray*}
%     \interp{
%         \inference{D : \types{\formphi}{\kProp}
%     }{
%         \types{\fForallTerm{\termv}\formphi}{\kProp}}
%     } & = & \underset{T \in Term}{\bigwedge} {\interp[{\tmEnv [\termv \mapsto T]}]{D}}  \\
%     \interp{
%         \inference{D : \types{\formphi}{\kProp}
%     }{
%         \types{\fForallAtom{\atomv}\formphi}{\kProp}}
%     } & = & \underset{A \in Atom}{\bigwedge} {\interp[{\tmEnv [\atomv \mapsto A]}]{D}} \\
%     \interp{
%         \inference{D : \types{\formphi}{\kProp}
%     }{
%         \types{\fExistsTerm{\termv} \formphi}{\kProp}}
%     } & = & \underset{T \in Term}{\bigvee}\interp[{\tmEnv [\termv \mapsto T]}]{D} \\
%     \interp{
%         \inference{D : \types{\formphi}{\kProp}
%     }{
%         \types{\fExistsAtom{\atomv} \formphi}{\kProp}}
%     } & = & \underset{A \in Atom}{\bigvee} \interp[{\tmEnv [\atomv \mapsto A]}]{D}
% \end{eqnarray*}

% \begin{eqnarray*}
%    \interp{
%         \inference{D : \types[\Gamma, c]{\formphi}{\kProp}
%     }{
%         \types{[c] \wedge \formphi}{\kProp}}
%     } & = &  \texttt{if } \tmEnv \vDash c \texttt{ then } \interp{D} \texttt{ else } \bot
%     \\
%     \interp{
%         \inference{D : \types[\Gamma, c]{\formphi}{\kProp}
%     }{
%         \types{[c] \Rightarrow \formphi}{\kProp}}
%     } & = &  \texttt{if } \tmEnv \vDash c \texttt{ then } \interp{D} \texttt{ else } \top
% \end{eqnarray*}

% \begin{eqnarray*}
%     \interp{\inference{D : \types{\formphi}{\kind_2}}{\types{\lam[\propv]\formphi}{\kind_1\karr\kind_2}}} & = &
%     \lambda\;(Q : \interp{\kind_1}).\;\interp[{\tmEnv[\propv\mapsto Q]}]{D}
%     \\
%     \interp{\inference{D: \types{\formphi}{\kind}}{\types{\lam[\atomv]\formphi}{\kForallAtom{\atomv}\kind}}} & = &
%     \lambda\;(A : Atom).\;\interp[{\tmEnv[\atomv\mapsto A]}]{D}
%     \\
%     \interp{\inference{D: \types{\formphi}{\kind}}{\types{\lam[\termv]\formphi}{\kForallTerm{\termv}\kind}}} & = &
%     \lambda\;(T : Term).\;\interp[{\tmEnv[\termv\mapsto T]}]{D}
% \end{eqnarray*}

% \begin{eqnarray*}
%     \interp{\inference{D_1: \types{\formphi_1}{\kind'\karr\kind} \\ D_2: \types{\formphi_2}{\kind'}}{\types{\formphi_1\;\formphi_2}{\kind}}} & = &
%     \interp{D_1}\; \interp{D_2}
%     \\
%     \interp{\inference{D: \types{\formphi}{\kForallAtom{\atomv}\kind}}{\types{\formphi(\atomexp)}{\kind\{\atomv \mapsto \atomexp\}}}} & = &
%     \interp{D}\;\interp{\atomexp}
%     \\
%     \interp{\inference{D: \types{\formphi}{\kForallTerm{\termv}\kind}}{\types{\formphi(\term)}{\kind\{\termv \mapsto \term\}}}} & = &
%     \interp{D}\;\interp{\termv}
% \end{eqnarray*}

% %  lim w sensie tw kleenego o fixpoincie
% \begin{eqnarray*}
%     \interp{\inference{
%             D : \types[{\Gamma, X : {\all[z]{[z < \termv']}}\;\kind\subst{z}{\termv'}}]\formphi\kind
%         }{
%             \types{\fix{X}{\termv'}\formphi}{\all[\termv']\kind}
%         }} & = & \lim_{n \rightarrow \infty} f_n
%     \\
%     & & \texttt{ where } f_0(t) = \bot \\
%     & & \texttt{ and } f_{n+1}(t) = \interp[{\tmEnv[X\mapsto f_n, \termv' \mapsto t]}]{D} \\
%     \interp{\inference{
%             D : \types[\Gamma, c]\formphi\kind
%         }{
%             \types{\formphi}{[c]\kind}
%         }} & = & \texttt{if } \tmEnv \vDash c \texttt{ then } \interp{D} \texttt{ else } \text{''}\bot\text{''}
%     \\
%     \interp{\inference{
%             D : \types\formphi\kind \\
%             \rel[\Gamma] \kind \leq \kind'
%         }{
%             \types{\formphi}{\kind'}
%         }} & = &  \interp{D}
% \end{eqnarray*}

% \section{Fundamental Theorem}
% For any formula $\formphi$, any kind $\kind$, and any environment $\Gamma$, for any kind derivation $D : \types\formphi\kind$ under any interpretation $\tmEnv \in \interp[]{\Gamma}$, we have that
% $$
%     \interp{D} \in \interp{\kind}
% $$
% In other words, each kind derivation $D$ has a semantic witness that inhabits the semantic interpretation of $\kind$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Proof assistant}
All the stuff mentioned above has their implementation in OCaml,
in modules \tt{Solver} and \tt{SolverEnv},
\tt{KindChecker} and \tt{KindCheckerEnv},
\tt{Proof} and \tt{ProofEnv}, respectively.

Constraints, kinds, and formulas constructors mirror the grammars we defined
in previous chapters.
Atoms and variables are represented internally by integers (but still are disjoint sets)
--- and their string \it{names} are kept in the environment and binders
(quantifiers and functions).

Additionally, we provide a \it{proof assistant} (in module \tt{Prover}),
that enables the user to conveniently work with \it{backwards} and incomplete
proof --- inspired by the HOL family of theorem provers.
While simple, it is also powerful and easy to use.
The interface to the Prover provides multiple \it{tactics}
(functions that manipulate \it{prover state}) and ways to combine them:
\begin{lstlisting}[mathescape, language=OCaml]
type goal_env = (string * formula) ProofEnv.env

type goal = goal_env * formula

type prover_state = S_Unfinished of {goal: goal; context: proof_context}
                  | S_Finished of proof

type tactic = prover_state $\rightarrow$ prover_state

val proof : goal_env $\rightarrow$ formula $\rightarrow$ prover_state

val qed : prover_state $\rightarrow$ proof

val (|>) : prover_state $\rightarrow$ tactic $\rightarrow$ prover_state

val (%>) : tactic $\rightarrow$ tactic $\rightarrow$ tactic

val repeat : tactic $\rightarrow$ tactic

val try_tactic : tactic $\rightarrow$ tactic
\end{lstlisting}
\newcommand{\hole}{\ensuremath{\bullet}}
\begin{eqnarray*}
  \text{\lstinline[columns=fixed]{proof}}\;(\Gamma,\Theta,\Sigma)\;\formphi &  \leadsto & \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind\formphi}
  \end{eqnarray*}
We begin description of the Prover interface with \it{empty} proof constructor,
using $\hole\ofkind\formphi$ to describe incomplete proofs,
called \it{holes} or \it{goals}.
\begin{eqnarray*}
  \text{\lstinline[columns=fixed]{intro}} & & \\
    \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{\fCImp{\constr}{\formphi}}} & \leadsto & \jgmnt[\Gamma, \constr; \Theta; \Sigma]{\hole\ofkind\formphi} \\
  & & \\
  \text{\lstinline[columns=fixed]{intro' x}} & & \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{\psi\fImp\formphi}} & \leadsto & \jgmnt[\Gamma; \Theta, \tt{x} \ofkind\psi ; \Sigma]{\hole\ofkind\formphi} \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{\fForallAtom{\atomv}{\formphi}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma, \tt{x} \ofkind\atomv]{\hole\ofkind\formphi} \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{\fForallTerm{\termv}{\formphi}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma, \tt{x} \ofkind\termv]{\hole\ofkind\formphi} \\
  & & \\
  \text{\lstinline[columns=fixed]{apply} } (\psi \fImp \formphi)& & \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{{\formphi}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind\psi} \\
  &   \text{and} & \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind\psi \fImp \formphi} \\
  & & \\
  \text{\lstinline[columns=fixed]{apply_thm} }  \mathcal{T} & & \\
    \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{{\formphi}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind\psi} \\
   & \text{where} & \mathcal{T} \;\text{is a proof of }\; {\psi \fImp \formphi } \\
  & & \\
  \text{\lstinline[columns=fixed]{apply_assm H}} & & \\
    \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{{\formphi}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind\psi} \\
   & \text{when} & (\tt{H} \ofkind {\psi\fImp\formphi }) \in \Theta \\
  & & \\
  \text{\lstinline[columns=fixed]{apply_assm_specialized H [e; a]}} & & \\
    \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{{\formphi(\tt{e}, \tt{a})}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind\psi(\tt{e}, \tt{a})} \\
   & \text{when} & (\tt{H} \ofkind {\kForallTerm{X}\kForallAtom{a} \psi(X, a)\fImp\formphi(X, a) }) \in \Theta
  \end{eqnarray*}
Now, some typical tactics: introduction of names and assumptions and applying of
propositions and theorems.
Note that propositions can be applied not only on the goal, but also on other
assumptions via \tt{apply\_in\_assumption} tactic.
One can also add introduce assumptions to the proof context from theorems via \tt{add\_assumption\_thm}
(specialized if needed --- \tt{add\_assumption\_thm\_specialized}) --
or simply add any assumption to the current context together with a new goal (of proving that assumption)
via \tt{add\_assumption}.
\begin{eqnarray*}  \text{\lstinline[columns=fixed]{apply_assm H}} & & \\
    \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{{\formphi}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma]{\formphi} \\
   & \text{when} & (\tt{H} \ofkind {\formphi }) \in \Theta \\
  & & \\
  \text{\lstinline[columns=fixed]{by_solver} }& & \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{{\constr}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma]{\constr} \\
   & \text{when} & \cjgmnt[\Gamma]{\constr}\\
  & & \\
  \text{\lstinline[columns=fixed]{discriminate} }& & \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{{\formphi}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma]{\formphi} \\
   & \text{when} & \cjgmnt[\Gamma]{\bot}
  \end{eqnarray*}
Above tactics finish the proofs, either by finding the goal in assumptions
(which can be made automatically via tactical\tt{assumption}),
or by running Solver on constraint-assumption and the goal.
Technical detail is that all formulas in $\Theta$ that are actually constraints
will also be included in calls to Solver.
\begin{eqnarray*}
  \text{\lstinline[columns=fixed]{exists e} }& & \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{\fExistsAtom{\atomv}{\formphi}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{\formphi\subst{\atomv}{\tt{e}}}} \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{\fExistsTerm{\termv}{\formphi}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{\formphi\subst{\termv}{\tt{e}}}} \\
  & & \\
  \text{\lstinline[columns=fixed]{destr_goal} }& & \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{\fCAnd{\constr}\formphi}} & \leadsto & \jgmnt[\Gamma; \Theta;\Sigma]{\hole\ofkind{\constr}} \\
  & \text{and} & \jgmnt[\Gamma; \Theta;\Sigma]{\hole\ofkind{\formphi}} \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{\formphi_1 \wedge \formphi_2}} & \leadsto & \jgmnt[\Gamma; \Theta;\Sigma]{\hole\ofkind{\formphi_1}} \\
  & \text{and} & \jgmnt[\Gamma; \Theta;\Sigma]{\hole\ofkind{\formphi_2}} \\
  & & \\
  \text{\lstinline[columns=fixed]{left} } & \equiv &  \text{\lstinline[columns=fixed]{case l} } \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{(\tt{l:}\:\formphi_1) \vee (\tt{r:}\:\formphi_2)}} & \leadsto & \jgmnt[\Gamma; \Theta;\Sigma]{\hole\ofkind{\formphi_1}} \\
  \text{\lstinline[columns=fixed]{right} } & \equiv &  \text{\lstinline[columns=fixed]{case r} } \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{(\tt{l:}\:\formphi_1) \vee (\tt{r:}\:\formphi_2)}} & \leadsto & \jgmnt[\Gamma; \Theta;\Sigma]{\hole\ofkind{\formphi_2}} \\
  \end{eqnarray*}
Tactics above reduce the current goal.
\begin{eqnarray*}
  \text{\lstinline[columns=fixed]{destr_assm H} }& & \\
  \jgmnt[\Gamma; \Theta \cup \{\tt{H}\ofkind \fCAnd{\constr}{\formphi} \}; \Sigma]{\hole\ofkind{\formphi}} & \leadsto & \jgmnt[{\Gamma \cup \{\constr\}}; \Theta \cup {\{ \tt{H} \ofkind \formphi\}}; \Sigma]{\hole\ofkind{\formphi}} \\
  \jgmnt[\Gamma; \Theta \cup \{\tt{H}\ofkind \formphi_1 \wedge \formphi_2 \}; \Sigma]{\hole\ofkind{\formphi}} & \leadsto & \jgmnt[{\Gamma; \Theta \cup {\{ \tt{H\_1}\ofkind \formphi_1, \tt{H\_2}\ofkind \formphi_2\}}; \Sigma}]{\hole\ofkind{\formphi}} \\
  \jgmnt[\Gamma; \Theta \cup \{\tt{H}\ofkind \formphi_1 \vee \formphi_2 \}; \Sigma]{\hole\ofkind{\formphi}} & \leadsto & \jgmnt[\Gamma; \Theta  \cup \{\tt{H}\ofkind \formphi_1\}; \Sigma]{\hole\ofkind{\formphi}} \\
  & \text{and} & \jgmnt[\Gamma; \Theta  \cup \{\tt{H}\ofkind \formphi_2\}; \Sigma]{\hole\ofkind{\formphi}} \\
  \text{\lstinline[columns=fixed]{destr_assm' H x} }& &
  \\
  \jgmnt[\Gamma; \Theta \cup \{\tt{H}\ofkind\fExistsAtom{\atomv}{\formphi} \}; \Sigma]{\hole\ofkind{\formphi}} & \leadsto & \jgmnt[\Gamma ; \Theta \cup {\{\tt{H}\ofkind\formphi\subst{\atomv}{\tt{x}}\}}; \Sigma\cup {\{\tt{x} \ofkind {A}\}}]{\hole\ofkind{\formphi}} \\
  \jgmnt[\Gamma; \Theta \cup \{\tt{H}\ofkind\fExistsTerm{\termv}{\formphi} \}; \Sigma]{\hole\ofkind{\formphi}} & \leadsto & \jgmnt[\Gamma ; \Theta \cup {\{\tt{H}\ofkind\formphi\subst{\termv}{\tt{x}}\}}; \Sigma\cup {\{\tt{x} \ofkind {T}\}}]{\hole\ofkind{\formphi}} \\
   & \text{when} & \tt{x} \notin \fv[\Gamma; \Theta; \Sigma]
  \end{eqnarray*}
Tactics above reduce formulas in assumptions.
Note that the user provides \tt{destr\_assm'} with a \it{name} that will be bound
with existential variable, but the binding is done \it{behind the scenes} and
actually any string can be given and an unique internal identifier is generated.
\begin{eqnarray*}
  \text{\lstinline[columns=fixed]{ex_falso} } & & \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{{\formphi}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind\bot} \\
  & & \\
  \text{\lstinline[columns=fixed]{generalize x} }& & \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{{\formphi}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma']{\hole\ofkind{\kForallTerm{\tt{x}}{\formphi}}} \\
  & \text{when} & \Sigma = \Sigma' \cup \{\tt{x}\} \text{ and } \tt{x} \notin \fv[\Gamma] \\
  & & \\
  \text{\lstinline[columns=fixed]{by_induction x IH} } & & \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{(\fForallTerm{\termv}\formphi(\termv))}} & \leadsto & \jgmnt[\Gamma; \Theta \cup \{\tt{IH} \ofkind \psi \};\Sigma\cup \{\tt{x} \ofkind {T}\}]{\hole\ofkind{\formphi(\termv)}} \\
   & \text{where} & {\psi := \fForallTerm{\tt{x}}\fCImp{\tt{x} \cshlt \termv}{\formphi(\tt{x})}}
  \end{eqnarray*}
Finally we can prove goals through generalization, induction on terms, and through reduction to absurd.
\begin{eqnarray*}
  \text{\lstinline[columns=fixed]{compare_atoms a b} }& & \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{{\formphi}}} & \leadsto & \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{(\tt{a} \ceq \tt{b} \vee \tt{a}\cneq \tt{b})\fImp{\formphi}}} \\
  & & \\
  \text{\lstinline[columns=fixed]{get_fresh_atom a e} }& & \\
  \jgmnt[\Gamma; \Theta; \Sigma]{\hole\ofkind{{\formphi}}} & \leadsto & \jgmnt[\Gamma \cup {\{\tt{a} \cfresh \tt{e}\}}; \Theta; \Sigma\cup {\{\tt{a} \ofkind {A}\}}]{\hole\ofkind{\formphi}} \\
   & \text{where} & \tt{a} \notin \fv[\Gamma; \Theta; \Sigma] \\
\end{eqnarray*}
We also provide shorthand formuals for using the axioms of our logic, described
in previous chapter.
Again argument \tt{a} to \tt{get\_fresh\_atom} is given by name and is bound by
a fresh internal identifier automatically.

Additional we provide the user with some auxiliary tactics:
\tt{trivial} th
\begin{itemize}
\item \tt{subst} --- substitutes atoms for atom expreesions
  and variables for terms in goal and environment
  --- as long as Solver proves their equality,
\item \tt{compute} --- computes WHNF of the current goal,
\item \tt{try} --- applies a tactic and returns unchanged state if the tactic fails
\item \tt{repeat} --- applies given tactic (until failure),
\item \tt{trivial} ---  tries applying some simple tactics
\end{itemize}

Lastly, function \tt{qed} takes a prover state and closes it:
if it's finished it will convert it into a forward proof that is ensured to be
correct by the simple rules inside Proof smart constructors.

Additionally, we allow conjunction and disjunction to have more than two arguments
and the  arguments to be labeled by names
- which gives the user an easy way to select the desired branch while writing proofs.

Naturally, we also provide a pretty-printer (written using library \tt{EasyFormat})
and a parser (written using parser combinator library \tt{Angstrom})
for terms, constraints, kinds and formulas.
See how $Nat$ and $PlusEq$ predicates can be written using "programming" syntax:
\begin{lstlisting}[mathescape, language=OCaml]
let fix Nat(n) : * =
 zero: (n = 0)
 $\vee$
 succ: ($\exists$ m :term. [n = S m] $\wedge$ Nat m)

let fix PlusEq(n) : $\forall$ m k : term. * = fun m k : term $\rightarrow$
 zero: ([n = 0] $\wedge$ [m = k])
 $\vee$
 succ: ($\exists$ n' k' :term. [n = S n'] $\wedge$ [k = S k'] $\wedge$ PlusEq n' m k')
\end{lstlisting}
And a short proof that 1 is a natural number:
\begin{lstlisting}[mathescape, language=OCaml]
let nat_1_thm = arith_thm
    Nat {S 0}

let nat_1 =
  proof' nat_1thm (* goal: Nat {S 0} *)
  |> case "succ"  (* goal: $\exists$ m :term. [S 0 = S m] $\wedge$ Nat m *)
  |> exists "0"   (* goal: [S 0 = S 0] $\wedge$ Nat 0 *)
  |> by_solver    (* goal: Nat 0 *)
  |> case "zero"  (* goal: 0 = 0 *)
  |> by_solver    (* finished *)
  |> qed
\end{lstlisting}
Another example theorem could be the symmetry of addition:
\begin{lstlisting}[mathescape, language=OCaml]
let plus_symm_thm = arith_thm
  $\forall$ x y z :term. (IsNum x) $\implies$ (IsNum y) $\implies$
    (PlusEq x y z) $\implies$ (PlusEq y x z)
\end{lstlisting}
The proof of which is included in the \tt{examples} subdirectory of the project,
together with the case study from the next chapter.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Case study: Progress and Preservation of STLC}

The ultimate goal of our work is to create a logic for dealing with variable binding,
and there's no better way to put it to work than to prove some things about lambda calculus.

We will take a look at simply typed lambda calculus and examine proofs of
its two major properties of \it{type soundness}: \it{progress} and \it{preservation}.
But before we delve into the proofs, let's first establish the needed relations:
\begin{lstlisting}[mathescape,language=OCaml]
let lambda_symbols = [lam; app; base; arrow; nil; cons]

let fix Term(e): * =
 var: ($\exists$ a :atom. [e = a])
 $\vee$
 lam: ($\exists$ a :atom.$\exists$ e' :term. [e = lam (a.e')] $\wedge$ (Term e'))
 $\vee$
 app: ($\exists$ e1 e2 :term. [e = app e1 e2] $\wedge$ (Term e1) $\wedge$ (Term e2))

let fix Type(t): * =
 base: (t = base)
 $\vee$
 arrow: ($\exists$ t1 t2 :term. [t $\ceq$ arrow t1 t2] $\wedge$ (Type t1) $\wedge$ (Type t2))

let fix InEnv(env): $\forall$ a :atom. $\forall$ t :term. * = fun (a :atom) (t :term) $\rightarrow$
 current: ($\exists$ env': term. [env = cons a t env'])
 $\vee$
 next: ($\exists$ b :atom. $\exists$ s env': term.
         [env = cons b s env'] $\wedge$ [a =/= b] $\wedge$ (InEnv env' a t))

let fix Typing(e): $\forall$ env t :term. * = fun env t :term $\rightarrow$
 var: ($\exists$ a :atom. [e = a] $\wedge$ (InEnv env a t))
 $\vee$
 lam: ($\exists$ a :atom.$\exists$ e' t1 t2 :term.
        [e = lam (a.e')] $\wedge$ [t = arrow t1 t2]
          $\wedge$ (Type t1) $\wedge$ (Typing e' {cons a t1 env} t2))
 $\vee$
 app: ($\exists$ e1 e2 t2 :term.
        [e = app e1 e2]
          $\wedge$ (Typing e1 env {arrow t2 t}) $\wedge$ (Typing e2 env t2))
\end{lstlisting}
For the proof of \it{progress}, we will naturally need the predicate
that a term is \it{progressive}, and a lemma about \it{canonical forms},
which states that all values in the empty environment
are of \it{arrow} type and can be \it{inversed} into an abstraction term
(since we did not consider any true base types like \tt{Bool} or \tt{Int}).
Other lemmas are unimportant boilerplate.
\begin{lstlisting}[mathescape,language=OCaml]
let Value :: $\forall$ e :term.* = fun e :term $\rightarrow$
 var: (exists a :atom. [e = a])
 $\vee$
 lam: (exists a :atom. $\exists$ e' : term. [e = lam (a.e')] $\wedge$ (Term e'))

let fix Steps(e): $\forall$ e' :term.* = fun e' :term $\rightarrow$
 app_l: ($\exists$ e1 e1' e2 :term. [e = app e1 e2]
          $\wedge$ [e' = app e1' e2] $\wedge$ (Steps e1 e1') )
 $\vee$
 app_r: ($\exists$ v e2 e2' :term. [e = app v e2]
          $\wedge$ [e' = app v e2'] $\wedge$ (Value v) $\wedge$ (Steps e2 e2') )
 $\vee$
 app: ($\exists$ a :atom.$\exists$ e_a v :term. [e = app (lam (a.e_a)) v]
        $\wedge$ (Value v) $\wedge$ (Sub e_a a v e') )

let Progressive :: $\forall$ e :term.* = fun e:term $\rightarrow$
 value: (Value e)
 $\vee$
 steps: (exists e' :term. Steps e e')

let canonical_form_thm = lambda_thm
  $\forall$ v :term. (Value v) $\implies$
  $\forall$ t :term. (Typing v nil t) $\implies$
     ($\exists$ a :atom. $\exists$ e :term. [v = lam (a.e)] $\wedge$ (Term e))
       $\wedge$
     ($\exists$ t1 t2 :term. [t = arrow t1 t2])

let progress_thm = lambda_thm
  $\forall$ e t :term. (Typing e nil t) $\implies$ (Progressive e)

let empty_contradiction_thm = lambda_thm
  $\forall$ a :atom. $\forall$ t :term. (InEnv nil a t) $\implies$ false

let typing_terms_thm = lambda_thm
  $\forall$ e env t : term. (Typing e env t) $\implies$ (Term e)

let subst_exists_thm = lambda_thm
  $\forall$ a :atom.
  $\forall$ v :term. (Value v) $\implies$
  $\forall$ e :term. (Term e) $\implies$
    $\exists$ e' :term. (Sub e a v e')
\end{lstlisting}
Otherwise the proof is a simple induction over $Typing$ derivation:
\begin{lstlisting}[language=OCaml]
let progress =
  proof' progress_thm
  |> by_induction "e0" "IH" %> intro
\end{lstlisting}
\begin{lstlisting}[mathescape]
Unfinished:
[ ]
[ IH : $\forall$ e0 : term. [e0 $\cshlt$ e] $\implies$ $\forall$ t'1 : term.
        (Typing {e0} {nil} {t'1}) $\implies$ Progressive {e0} ]
$\vdash$ (Typing {e} {nil} {t}) $\implies$ Progressive {e}
\end{lstlisting}
To analyze all the possible branches of the \tt{Typing} predicate,
we simply use \tt{{destr\_intro}} tactic to destruct the assumption into multiple branches.
\begin{lstlisting}[language=OCaml]
  |> destr_intro
\end{lstlisting}
First one is that \tt{e} is a variable - which contradicts with empty enviroment:
\begin{lstlisting}[language=OCaml]
  |> intros' ["contra"; "a"; ""]
     %> ex_falso
     %> apply_thm_specialized empty_contradiction ["a"; "t"]
     %> assumption
\end{lstlisting}
Next, \tt{e} is a lambda abstraction - so a value.
\begin{lstlisting}[mathescape, language=OCaml]
  |> intros' ["Hlam"; "a"; "e_a"; "t1"; "t2"; ""; ""; ""]
     %> case "value"
Unfinished:
[ e = lam (a.e_a) ; t = arrow t1 t2 ]
[
  Hlam_2 : Typing {e_a} {cons a t1 nil} {t2} ;
  Hlam_1 : Type {t1} ;
  $\cdots$
]
$\vdash$ Value {e}
\end{lstlisting}
\begin{lstlisting}[mathescape,language=OCaml]
     %> case "lam"
     %> exists' ["a"; "e_a"]
     %> by_solver
     %> apply_thm_specialized typing_terms ["e_a"; "cons a t1 nil"; "t2"]
     %> assumption
  |> intros' ["Happ"; "e1"; "e2"; "t2"; ""; ""]
    (* e is an application - steps *)
  |> add_assumption_parse "He1" "Progressive e1"
  |> add_assumption_parse "He2" "Progressive e2"
  |> destruct_assm "He1"
     %> intros ["Hv1"]
     %> destruct_assm "He2"
     %> intros ["Hv2"] (* Value e1, Value e2 *)
     %> ( add_assumption_thm_specialized "He1lam" canonical_form' ["e1"; "t2"; "t"]
        (* He1lam: [e1 = lam (a.e_a)] $\wedge$ (Term e_a) *)
        %> apply_in_assm "He1lam" "Hv1"
        %> apply_in_assm "He1lam" "Happ_1"
        %> destruct_assm' "He1lam" ["a"; "e_a"; ""] )
     %> ( add_assumption_thm_specialized "He_a" subst_exists ["a"; "e2"; "e_a"]
        %> apply_in_assm "He_a" "Hv2"
        %> apply_in_assm "He_a" "He1lam"
        %> destruct_assm' "He_a" ["e_a'"] (* He_a: Sub e_a a e2 e_a' *) )
     %> case "steps"
     %> exists "e_a'"
     %> case "app"
     %> exists' ["a"; "e_a"; "e2"]
     %> by_solver
     %> destruct_goal
     %> apply_assm "Hv2"
     %> apply_assm "He_a"
  |> intros' ["Hs2"; "e2'"] (* Value e1, Steps e2 e2' *)
     %> case "steps"
     %> exists "app e1 e2'"
     %> case "app_r"
     %> exists' ["e1"; "e2"; "e2'"]
     %> by_solver
     %> by_solver
     %> destruct_goal
     %> apply_assm "Hv1"
     %> apply_assm "Hs2"
  |> intros' ["Hs1"; "e1'"] (* Steps e1 *)
     %> case "steps"
     %> exists "app e1' e2"
     %> case "app_l"
     %> exists' ["e1"; "e1'"; "e2"]
     %> by_solver
     %> by_solver
     %> apply_assm "Hs1"
  |> apply_assm_specialized "IH" ["e2"; "t2"] %> by_solver
    %> apply_assm "Happ_2" (* Progressive e2 *)
  |> apply_assm_specialized "IH" ["e1"; "arrow t2 t"] %> by_solver
    %> apply_assm "Happ_1" (* Progressive e1 *)
  |> qed
\end{lstlisting}

To prove \it{Preservation}, we will need some more relations and lemmas:
\begin{lstlisting}[mathescape, language=OCaml]
let fix Sub(e): $\forall$ a :atom. $\forall$ v e':term.* = fun (a :atom) (v e' :term) $\rightarrow$
 var_same: ([e = a] $\wedge$ [e' = v])
 $\vee$
 var_diff: (exists b :atom. [e = b] $\wedge$ [e' = b] $\wedge$ [a =/= b])
 $\vee$
 lam: ($\exists$ b :atom. $\exists$ e_b e_b' :term. [e = lam (b.e_b)] $\wedge$
        [e' = lam (b.e_b')] $\wedge$ [b # v] $\wedge$ [a =/= b] $\wedge$ (Sub e_b a v e_b') )
 $\vee$
 app: ($\exists$ e1 e2 e1' e2' :term.
        [e = app e1 e2] $\wedge$ [e' = app e1' e2']
          $\wedge$ (Sub e1 a v e1') $\wedge$ (Sub e2 a v e2') )

let EnvInclusion :: $\forall$ env1 env2 :term.* = fun env1 env2 : term $\rightarrow$
  $\forall$ a : atom. $\forall$ t : term. (InEnv env1 a t) $\implies$ (InEnv env2 a t)
\end{lstlisting}

1. Substitution lemma:
if term $e$ has a type $t$ in enviroment ${cons}\fAppAtom{a}\fAppTerm{ta}\fAppTerm{env}$,
then we can substitute $a$ for any value $v$ of type $ta$ in $e$ without breaking the typing.
\begin{lstlisting}[mathescape,language=OCaml]
let sub_lemma_thm = lambda_thm
  $\forall$ e env t :term.
  $\forall$ a : atom. $\forall$ ta :term.
  $\forall$ v e' :term.
    (Typing v env ta) $\implies$
    (Typing e {cons a ta env} t) $\implies$
    (Sub e a v e') $\implies$
      (Typing e' env t)
\end{lstlisting}

2. Swap lemma:
If we have a typing of $e$ in $env$ then we can
swap $a$ with (\it{fresh enough}) $b$ in both $e$ and $env$ without breaking the typing.
This is particularly useful for mainipulating the abstraction terms ---
we can have any atom we want in the argument position while preserving typing.
!!! TODO: Is this an example of a property that should be true in nominal logic
by the law of permuting predicates?
\begin{lstlisting}[mathescape,language=OCaml]
let swap_lambda_typing_thm = lambda_thm
  $\forall$ e env t :term.
  $\forall$ a b :atom. $\forall$ t' :term.
    [b # e] $\implies$
    (Typing e {cons a t' env} t) $\implies$
      (Typing {[a b]e} {cons b t' env} t)
\end{lstlisting}

3. Weakening lemma: for any enviroment $env_1$, we can use larger enviroment $env_2$ without breaking the typing.
\begin{lstlisting}[mathescape,language=OCaml]
let weakening_lemma_thm = lambda_thm
  $\forall$ e env1 t env2 : term.
    (Typing e env1 t) $\implies$
    (EnvInclusion env1 env2) $\implies$
      (Typing e env2 t)
\end{lstlisting}

Now to the proof:
\begin{lstlisting}[mathescape, language=OCaml]
let preservation =
  let contra_var = $\cdots$
  let contra_app = $\cdots$
  let deduce_app_typing = $\cdots$
  in
  proof' preservation_thm
  |> by_induction "e0" "IH"
  |> intro %> intro %> intro %> intros ["Htyp"; "Hstep"]
  |> destruct_assm "Hstep"
  |> intros' ["He1"; "e1"; "e1'"; "e2"; ""; ""]
    (* e = app e1 e2, Steps e1 e1' *)
     %> deduce_app_typing
     %> case "app"
     %> exists' ["e1'"; "e2"; "t2"]
     %> by_solver
     %> destruct_goal
     %> apply_assm_specialized "IH" ["e1"; "e1'"; "env"; "arrow t2 t"]
     (* Typing e1 env {arrow t2 t} $\implies$
            Steps e1 e1' $\implies$ Typing e1' env {arrow t2 t} *)
     %> by_solver
     %> apply_assm "Happ_1"
     %> apply_assm "He1"
     (* Typing e2 env t2 *)
     %> apply_assm "Happ_2"
  |> intros' ["He2"; "v1"; "e2"; "e2'"; ""; ""; ""]
     (* e = app v1 e2, Value e1, Steps e2 e2' *)
     %> deduce_app_typing
     %> case "app"
     %> exists' ["v1"; "e2'"; "t2"]
     %> by_solver
     %> destruct_goal
     (* Typing e1 env {arrow t2 t} *)
     %> apply_assm "Happ_1"
     (* Typing e2 env t2 $\implies$ Steps e2 e2' $\implies$ Typing e2' env t2*)
     %> apply_assm_specialized "IH" ["e2"; "e2'"; "env"; "t2"]
     %> by_solver
     %> apply_assm "Happ_2"
     %> apply_assm "He2_2"
  |> intros' ["Hbeta"; "a"; "e_a"; "v"; ""; ""]
     (* e = app (lam (a.e_a)) v, Value v *)
     %> deduce_app_typing
     %> destruct_assm "Happ_1"
     %> contra_var (* e_1 =/= var *)
     %> intros' ["Hlam"; "b"; "e_b"; "t1b"; "t2b"; ""; ""; ""] (* e_1 = b.e_b *)
     %> apply_thm_specialized sub_lemma ["e_a"; "env"; "t"; "a"; "t2"; "v"; "e'"]
     (* Typing v env t2 $\implies$ Typing e_a {cons a t2 env} t $\implies$
            Sub e_a a v e' $\implies$ Typing e' env t *)
     %> apply_assm "Happ_2" (* Typing v env t2 *)
     %> compare_atoms "a" "b" (* Typing e_a cons a t2 env t *)
     %> destr_intro
     (* a = b *) %> apply_assm "Hlam_2"
     %> destr_intro (* a =/= b *)
     (* [a # b e_b] $\implies$ Typing e_b {cons b t2 env} t $\implies$
            Typing {[b a]e_b} {cons a t2 env} t *)
     %> apply_thm_specialized
        swap_lambda_typing ["e_b"; "env"; "t"; "b"; "a"; "t2"]
     %> by_solver
     %> apply_assm "Hlam_2"
     %> apply_assm "Hbeta_2" (* Sub e_a a v e' *)
     %> contra_app (* e_1 =/= app _ _ *)
  |> qed
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion and future work}

\dots

%%%%% BIBLIOGRAFIA

\begin{thebibliography}{1}
\bibitem{example} \ldots
\end{thebibliography}

\end{document}
